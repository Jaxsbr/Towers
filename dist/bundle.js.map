{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://towers/./src/AssetLoading/assetManager.ts","webpack://towers/./src/AssetLoading/imageAsset.ts","webpack://towers/./src/DataObjects/gameTime.ts","webpack://towers/./src/DataObjects/imageObject.ts","webpack://towers/./src/DataObjects/rectangle.ts","webpack://towers/./src/DataObjects/vector2.ts","webpack://towers/./src/Enemies/enemy.ts","webpack://towers/./src/Enemies/enemySpawner.ts","webpack://towers/./src/Levels/levelManager.ts","webpack://towers/./src/Menu/menu.ts","webpack://towers/./src/Projectiles/projectile.ts","webpack://towers/./src/Projectiles/projectileEngine.ts","webpack://towers/./src/Scenes/gameScene.ts","webpack://towers/./src/Scenes/loadScene.ts","webpack://towers/./src/Scenes/sceneManager.ts","webpack://towers/./src/Scenes/scenes.enum.ts","webpack://towers/./src/Tiles/tile.ts","webpack://towers/./src/Tiles/tileMap.ts","webpack://towers/./src/Towers/baseTower.ts","webpack://towers/./src/Towers/plainTower.ts","webpack://towers/./src/Towers/towerManager.ts","webpack://towers/./src/gameConfig.ts","webpack://towers/./src/renderEngine.ts","webpack://towers/webpack/bootstrap","webpack://towers/./src/game.ts"],"sourcesContent":["import { Level } from '../Levels/level';\r\nimport { ImageAsset } from './imageAsset';\r\n\r\nexport class AssetManager {\r\n    images: ImageAsset[] = [];\r\n\r\n    levelInfo: Level[] = [];\r\n\r\n    levelInfoLoaded: boolean;\r\n\r\n    totalAssets: number;\r\n\r\n    public loadedAssetCount: number;\r\n\r\n    public loadCompleted: boolean;\r\n\r\n    init(): void {\r\n        this.levelInfoLoaded = false;\r\n        this.loadCompleted = false;\r\n        this.totalAssets = 0;\r\n        this.initAssets();\r\n    }\r\n\r\n    initAssets(): void {\r\n        const request = new XMLHttpRequest();\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.totalAssets = data.assetCount;\r\n                this.initImages(data.imageAssets);\r\n                this.initLevelInfo(data.levelInfoFile);\r\n            }\r\n        };\r\n        request.open('get', './assets/assetManifest.json', true);\r\n        request.send();\r\n    }\r\n\r\n    initImages(imageAssets: any): void {\r\n        imageAssets.forEach(asset => {\r\n            const image = new ImageAsset(asset.key, asset.src);\r\n            this.images.push(image);\r\n        });\r\n\r\n        this.images.forEach(img => {\r\n            img.init();\r\n        });\r\n    }\r\n\r\n    initLevelInfo(levelInfoFile: string): void {\r\n        if (!levelInfoFile) {\r\n            console.error('no level info file provided');\r\n            return;\r\n        }\r\n\r\n        const request = new XMLHttpRequest();\r\n\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.levelInfo = data;\r\n                this.levelInfoLoaded = true;\r\n            }\r\n        };\r\n        request.open('get', levelInfoFile, true);\r\n        request.send();\r\n    }\r\n\r\n    update(): void {\r\n        this.loadedAssetCount = this.images.filter(x => x.loaded).length;\r\n        this.loadedAssetCount = this.levelInfoLoaded\r\n            ? (this.loadedAssetCount += 1)\r\n            : this.loadedAssetCount;\r\n\r\n        if (this.totalAssets !== 0 && this.totalAssets === this.loadedAssetCount) {\r\n            this.loadCompleted = true;\r\n        }\r\n    }\r\n\r\n    getImage(key: string): HTMLImageElement {\r\n        return this.images.filter(x => x.key === key).at(0).image;\r\n    }\r\n}\r\n","export class ImageAsset {\r\n    public loaded: boolean;\r\n\r\n    public image: HTMLImageElement;\r\n\r\n    public key: string;\r\n\r\n    src: string;\r\n\r\n    constructor(key: string, src: string) {\r\n        this.loaded = false;\r\n        this.key = key;\r\n        this.src = src;\r\n    }\r\n\r\n    init(): void {\r\n        this.image = new Image();\r\n        this.image.onload = (): void => {\r\n            this.loaded = true;\r\n        };\r\n        this.image.src = this.src;\r\n    }\r\n}\r\n","export class GameTime {\r\n    public delta = 0;\r\n\r\n    private previousLoopTime: number = Date.now();\r\n\r\n    public update(): void {\r\n        const currentTime = Date.now();\r\n        const delta = currentTime - this.previousLoopTime;\r\n        this.delta = delta / 1000;\r\n        this.previousLoopTime = currentTime;\r\n    }\r\n}\r\n","import { Rectangle } from './rectangle';\r\n\r\nexport class ImageObject {\r\n    public image: HTMLImageElement;\r\n\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    public sx: number;\r\n\r\n    public sy: number;\r\n\r\n    public swidth: number;\r\n\r\n    public sheight: number;\r\n\r\n    private sourceRect: Rectangle = null;\r\n\r\n    private destinationRect: Rectangle = null;\r\n\r\n    public get sourceRectangle(): Rectangle {\r\n        if (this.sourceRect == null) {\r\n            this.sourceRect = new Rectangle(this.sx, this.sy, this.swidth, this.sheight);\r\n        }\r\n\r\n        return this.sourceRect;\r\n    }\r\n\r\n    public get destinationRectangle(): Rectangle {\r\n        if (this.destinationRect == null) {\r\n            this.destinationRect = new Rectangle(this.x, this.y, this.width, this.height);\r\n        }\r\n\r\n        return this.destinationRect;\r\n    }\r\n}\r\n","export class Rectangle {\r\n    public left: number;\r\n\r\n    public top: number;\r\n\r\n    public bottom: number;\r\n\r\n    public right: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    constructor(left: number, top: number, width: number, height: number) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.update();\r\n    }\r\n\r\n    private updateRight(): void {\r\n        this.right = this.left + this.width;\r\n    }\r\n\r\n    private updateBottom(): void {\r\n        this.bottom = this.top + this.height;\r\n    }\r\n\r\n    public update(): void {\r\n        this.updateRight();\r\n        this.updateBottom();\r\n    }\r\n\r\n    public intersectRect(rectangle: Rectangle): boolean {\r\n        return !(\r\n            rectangle.left > this.right ||\r\n            rectangle.right < this.left ||\r\n            rectangle.top > this.bottom ||\r\n            rectangle.bottom < this.top\r\n        );\r\n    }\r\n\r\n    public containsRect(rectangle: Rectangle): boolean {\r\n        return (\r\n            this.left <= rectangle.left &&\r\n            rectangle.right <= this.right &&\r\n            this.top <= rectangle.top &&\r\n            rectangle.bottom <= this.bottom\r\n        );\r\n    }\r\n\r\n    public get getCenterWidth(): number {\r\n        this.updateRight();\r\n        return this.right - this.width / 2;\r\n    }\r\n\r\n    public get getCenterHeight(): number {\r\n        this.updateBottom();\r\n        return this.bottom - this.height / 2;\r\n    }\r\n\r\n    public clone(): Rectangle {\r\n        return new Rectangle(this.left, this.top, this.width, this.height);\r\n    }\r\n\r\n    public equals(rect: Rectangle): boolean {\r\n        return (\r\n            this.left === rect.left &&\r\n            this.top === rect.top &&\r\n            this.width === rect.width &&\r\n            this.height === rect.height\r\n        );\r\n    }\r\n\r\n    public toString(): string {\r\n        return `x:${this.left} y: ${this.top} w: ${this.width} h:${this.height}`;\r\n    }\r\n\r\n    static get empty(): Rectangle {\r\n        return new Rectangle(0, 0, 0, 0);\r\n    }\r\n}\r\n","export class Vector2 {\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public subtract(vector2: Vector2): Vector2 {\r\n        return new Vector2(this.x - vector2.x, this.y - vector2.y);\r\n    }\r\n\r\n    public distance(vector2: Vector2): number {\r\n        const x = (this.x - vector2.x) * (this.x - vector2.x);\r\n        const y = (this.y - vector2.y) * (this.y - vector2.y);\r\n        return Math.sqrt(x + y);\r\n    }\r\n\r\n    public magnitude(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    public normalize(): Vector2 {\r\n        const distance = Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n        const normalX = this.x / distance;\r\n        const normalY = this.y / distance;\r\n\r\n        return new Vector2(\r\n            Number.isNaN(normalX) ? 0 : normalX,\r\n            Number.isNaN(normalY) ? 0 : normalY\r\n        );\r\n    }\r\n\r\n    static get empty(): Vector2 {\r\n        return new Vector2(0, 0);\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Enemy {\r\n    public position: Vector2;\r\n\r\n    public size: Vector2;\r\n\r\n    public active: boolean;\r\n\r\n    public center: Vector2;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    public futurePosition: Vector2;\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private originalWayPoints: any;\r\n\r\n    private movementWayPoints: any;\r\n\r\n    private wayPointReachedThreshold = 2;\r\n\r\n    private movements: any;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private nextMovePoint: Vector2;\r\n\r\n    private normalizedDirection: Vector2;\r\n\r\n    private distanceFromNextWaypoint: number;\r\n\r\n    private moveSpeed = 75;\r\n\r\n    private hp = 0;\r\n\r\n    private maxHp = 5;\r\n\r\n    private hpBounds: Rectangle;\r\n\r\n    private liveBounds: Rectangle;\r\n\r\n    private topPadding = 10;\r\n\r\n    private hpRemainingBarColor = 'red';\r\n\r\n    private hpFullBarColor = 'green';\r\n\r\n    private enemyName: string;\r\n\r\n    private alive = false;\r\n\r\n    constructor(enemyImage: HTMLImageElement) {\r\n        this.enemyImage = enemyImage;\r\n        this.originalWayPoints = window.tileMap.wayPoints;\r\n        this.reset(0, 0);\r\n    }\r\n\r\n    public reset(moveSpeed: number, maxHp: number): void {\r\n        this.active = false;\r\n        this.alive = false;\r\n        this.maxHp = maxHp;\r\n        this.hp = this.maxHp;\r\n        this.moveSpeed = moveSpeed;\r\n        this.movementWayPoints = this.originalWayPoints.slice();\r\n        this.movements = { left: false, right: false, up: false, down: false };\r\n        this.position = Vector2.empty;\r\n        this.futurePosition = Vector2.empty;\r\n        this.size = window.gameConfig.enemySize;\r\n        this.center = Vector2.empty;\r\n        this.velocity = Vector2.empty;\r\n        this.bounds = new Rectangle(0, 0, 0, 0);\r\n        this.nextMovePoint = null;\r\n        this.hpBounds = new Rectangle(\r\n            this.bounds.left,\r\n            this.bounds.top - this.topPadding,\r\n            this.bounds.width,\r\n            this.bounds.height\r\n        );\r\n        this.liveBounds = this.hpBounds.clone();\r\n        this.enemyName = Math.random().toString();\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        let onLastWaypoint = false;\r\n        if (this.movementWayPoints.length <= 0) {\r\n            onLastWaypoint = true;\r\n        }\r\n\r\n        if (!this.nextMovePoint) {\r\n            const firstWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds =\r\n                window.tileMap.tileMatrix[firstWayPoint.y][firstWayPoint.x].bounds;\r\n            this.nextMovePoint = new Vector2(\r\n                waypointBounds.getCenterWidth,\r\n                waypointBounds.getCenterHeight\r\n            );\r\n        }\r\n\r\n        this.updateBounds();\r\n        this.updateHpBounds();\r\n\r\n        this.direction = this.nextMovePoint.subtract(this.center);\r\n        this.distanceFromNextWaypoint = this.direction.magnitude();\r\n\r\n        if (this.nextWaypointReached()) {\r\n            if (onLastWaypoint) {\r\n                this.nextMovePoint = null;\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': end reached');\r\n                window.dispatchEvent(new CustomEvent('enemyReachedEnd'));\r\n                return;\r\n            }\r\n            const nextWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds = window.tileMap.tileMatrix[nextWayPoint.y][nextWayPoint.x].bounds;\r\n            this.nextMovePoint.x = waypointBounds.getCenterWidth;\r\n            this.nextMovePoint.y = waypointBounds.getCenterHeight;\r\n            this.direction = this.center.subtract(this.nextMovePoint);\r\n        }\r\n\r\n        this.normalizedDirection = this.direction.normalize();\r\n        if (\r\n            !Number.isNaN(this.normalizedDirection.x) &&\r\n            !Number.isNaN(this.normalizedDirection.y)\r\n        ) {\r\n            this.velocity.x = this.normalizedDirection.x * (this.moveSpeed * delta);\r\n            this.velocity.y = this.normalizedDirection.y * (this.moveSpeed * delta);\r\n            this.setMoveDirection();\r\n        }\r\n\r\n        this.applyVelocity();\r\n    }\r\n\r\n    private nextWaypointReached(): boolean {\r\n        return this.distanceFromNextWaypoint < this.wayPointReachedThreshold;\r\n    }\r\n\r\n    private updateBounds(): void {\r\n        this.bounds.left = this.position.x;\r\n        this.bounds.top = this.position.y;\r\n        this.bounds.width = this.size.x;\r\n        this.bounds.height = this.size.y;\r\n        this.bounds.update();\r\n\r\n        this.updateHpBounds();\r\n        this.updateLifeBounds();\r\n\r\n        this.center.x = this.bounds.getCenterWidth;\r\n        this.center.y = this.bounds.getCenterHeight;\r\n\r\n        this.futurePosition.x = this.center.x;\r\n        this.futurePosition.y = this.center.y;\r\n\r\n        this.futurePosition.x =\r\n            this.center.x + this.velocity.x * window.gameConfig.enemyFuturePositionModifier;\r\n        this.futurePosition.y =\r\n            this.center.y + this.velocity.y * window.gameConfig.enemyFuturePositionModifier;\r\n    }\r\n\r\n    private updateHpBounds(): void {\r\n        const percentageRemaining = (this.hp * 100) / this.maxHp;\r\n        const percentageDiff = 100 - percentageRemaining;\r\n\r\n        const percentageLive = (this.liveBounds.width * percentageDiff) / 100;\r\n        this.hpBounds.width = this.liveBounds.width - percentageLive;\r\n\r\n        this.hpBounds.left = this.bounds.left;\r\n        this.hpBounds.top = this.bounds.top;\r\n        this.hpBounds.height = this.bounds.height / this.topPadding;\r\n        this.hpBounds.update();\r\n    }\r\n\r\n    private updateLifeBounds(): void {\r\n        this.liveBounds.left = this.bounds.left;\r\n        this.liveBounds.top = this.bounds.top;\r\n        this.liveBounds.width = this.bounds.width;\r\n        this.liveBounds.height = this.bounds.height / this.topPadding;\r\n        this.liveBounds.update();\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 68, 80);\r\n\r\n        window.renderEngine.renderImageSource(this.enemyImage, sourceRectangle, this.bounds);\r\n\r\n        // TODO:\r\n        // Introduce damage percentage bar\r\n        this.drawRemainingHPBar();\r\n        this.drawFullHPBar();\r\n    }\r\n\r\n    private drawRemainingHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.liveBounds, this.hpRemainingBarColor, true);\r\n    }\r\n\r\n    private drawFullHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.hpBounds, this.hpFullBarColor, true);\r\n    }\r\n\r\n    private setMoveDirection(): void {\r\n        this.movements.left = this.velocity.x < 0;\r\n        this.movements.right = this.velocity.x > 0;\r\n\r\n        this.movements.up = this.velocity.y < 0;\r\n        this.movements.down = this.velocity.y > 0;\r\n\r\n        if (\r\n            (this.movements.left || this.movements.right) &&\r\n            (this.movements.up || this.movements.down)\r\n        ) {\r\n            // We detect if both horizontal and vertical movement is set.\r\n            // As we can only play one animation per axis movement we should determine\r\n            // what axis has the greater velocity value and use that as the direction.\r\n\r\n            const horizontalValue = this.velocity.x < 0 ? this.velocity.x * -1 : this.velocity.x;\r\n\r\n            const verticalValue = this.velocity.y < 0 ? this.velocity.y * -1 : this.velocity.y;\r\n\r\n            if (horizontalValue > verticalValue) {\r\n                this.movements.left = this.velocity.x < 0;\r\n                this.movements.right = this.velocity.x > 0;\r\n                this.movements.up = false;\r\n                this.movements.down = false;\r\n            } else {\r\n                this.movements.up = this.velocity.y < 0;\r\n                this.movements.down = this.velocity.y > 0;\r\n                this.movements.left = false;\r\n                this.movements.right = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyVelocity(): void {\r\n        this.position.x += this.velocity.x;\r\n        this.position.y += this.velocity.y;\r\n    }\r\n\r\n    public hit(): void {\r\n        if (this.active) {\r\n            this.hp -= 1;\r\n            // console.log(this.enemyName + ': hit ' + this.hp);\r\n\r\n            if (this.hp <= 0) {\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': killed');\r\n                window.dispatchEvent(new CustomEvent('enemyKilled'));\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Enemy } from './enemy';\r\n\r\nexport class EnemySpawner {\r\n    public enemies: Enemy[] = [];\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private enemySpawnCount = 0;\r\n\r\n    private enemySpawnCountMax: number;\r\n\r\n    private enemySpawnRate: number;\r\n\r\n    private enemySpawnElapsed = 0;\r\n\r\n    private enemiesKilled = 0;\r\n\r\n    private enemiesEscaped = 0;\r\n\r\n    constructor() {\r\n        this.enemyImage = window.assetManager.getImage('squid');\r\n        this.setCurrentLevel();\r\n\r\n        window.addEventListener('enemyKilled', () => {\r\n            this.enemiesKilled += 1;\r\n        });\r\n        window.addEventListener('enemyReachedEnd', () => {\r\n            this.enemiesEscaped += 1;\r\n        });\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.update(delta);\r\n        });\r\n\r\n        this.updateSpawner(delta);\r\n        this.updateRoundCheck();\r\n    }\r\n\r\n    private updateSpawner(delta: number): void {\r\n        if (this.enemySpawnCount >= this.enemySpawnCountMax) {\r\n            return;\r\n        }\r\n        this.enemySpawnElapsed += delta;\r\n        if (this.enemySpawnElapsed >= this.enemySpawnRate) {\r\n            this.enemySpawnElapsed = 0;\r\n            this.createEnemy();\r\n            this.enemySpawnCount += 1;\r\n        }\r\n    }\r\n\r\n    private updateRoundCheck(): void {\r\n        if (\r\n            this.enemiesEscaped + this.enemiesKilled ===\r\n            window.levelManager.currentLevel.enemySpawnCountMax\r\n        ) {\r\n            this.enemiesKilled = 0;\r\n            this.enemiesEscaped = 0;\r\n            this.enemySpawnCount = 0;\r\n            window.levelManager.nextLevel();\r\n            this.setCurrentLevel();\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.draw();\r\n        });\r\n    }\r\n\r\n    public createEnemy(): void {\r\n        // TODO:\r\n        // Reset inactive enemies from pool instead of creating new ones\r\n        // THIS IS A LEAK BTW\r\n        // console.clear();\r\n        // console.log(\"enemy in array count: \" + this.enemies.length);\r\n\r\n        const enemy = new Enemy(this.enemyImage);\r\n        enemy.reset(\r\n            window.levelManager.currentLevel.enemyMoveSpeed,\r\n            window.levelManager.currentLevel.enemyMaxHp\r\n        );\r\n        enemy.active = true;\r\n        this.enemies.push(enemy);\r\n    }\r\n\r\n    private setCurrentLevel(): void {\r\n        this.enemySpawnCountMax = window.levelManager.currentLevel.enemySpawnCountMax;\r\n        this.enemySpawnRate = window.levelManager.currentLevel.enemySpawnRate;\r\n    }\r\n}\r\n","import { Level } from './level';\r\n\r\nexport class LevelManager {\r\n    private levelInfo: Level[];\r\n\r\n    public currentLevel: Level;\r\n\r\n    constructor(levelInfo: Level[]) {\r\n        this.levelInfo = levelInfo;\r\n        this.loadLevel();\r\n    }\r\n\r\n    private loadLevel(): void {\r\n        if (this.currentLevel == null) {\r\n            this.currentLevel = this.levelInfo.at(0);\r\n        }\r\n    }\r\n\r\n    public nextLevel(): void {\r\n        const index = this.currentLevel.levelIndex + 1;\r\n        for (let l = 0; l < this.levelInfo.length; l += 1) {\r\n            if (this.levelInfo[l].levelIndex === index) {\r\n                this.currentLevel = this.levelInfo[l];\r\n                return;\r\n            }\r\n        }\r\n\r\n        // NOTE: If we get here, no more level exist\r\n        // TODO:\r\n        // Raise end of level notification\r\n        // console.log(\"last level done\")\r\n    }\r\n}\r\n","import { ImageKeyPair } from '../Types/imageKeyPair';\r\n\r\nexport class Menu {\r\n    public stagedTowerImageWidth = window.gameConfig.menuStagedTowerImageWidth;\r\n\r\n    public stagedTowerImageHeight = window.gameConfig.menuStagedTowerImageHeight;\r\n\r\n    private imageDictionary: ImageKeyPair[];\r\n\r\n    private stagedTower: string;\r\n\r\n    public menuHeight: number;\r\n\r\n    public hasStagedTower = false;\r\n\r\n    constructor() {\r\n        window.addEventListener('plainTowerClicked', () => {\r\n            this.towerClicked('plain');\r\n        });\r\n        window.addEventListener('slowTowerClicked', () => {\r\n            this.towerClicked('slow');\r\n        });\r\n        this.menuHeight = document.getElementById('tower_menu').clientHeight;\r\n\r\n        this.imageDictionary = [\r\n            { key: 'plain', image: window.assetManager.getImage('towerplain') },\r\n            { key: 'slow', image: window.assetManager.getImage('towerslow') }\r\n        ];\r\n    }\r\n\r\n    public clearStagedTower(): void {\r\n        this.stagedTower = '';\r\n        this.hasStagedTower = false;\r\n    }\r\n\r\n    private towerClicked(type: string): void {\r\n        this.stagedTower = type;\r\n        this.hasStagedTower = true;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!window.mouseInfo || !this.stagedTower) {\r\n            return;\r\n        }\r\n\r\n        const tX = window.mouseInfo.x - this.stagedTowerImageWidth / 2;\r\n        const tY = window.mouseInfo.y - this.stagedTowerImageHeight / 2 - this.menuHeight;\r\n\r\n        const { image } = this.imageDictionary.find(x => x.key === this.stagedTower);\r\n        window.renderEngine.renderImage(\r\n            image,\r\n            tX,\r\n            tY,\r\n            this.stagedTowerImageWidth,\r\n            this.stagedTowerImageHeight\r\n        );\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Projectile {\r\n    public active = false;\r\n\r\n    private startPosition: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private worldBounds: Rectangle;\r\n\r\n    private inWorldBounds: boolean;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private moveSpeed = 0.5;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private ttl = 0;\r\n\r\n    private ttlMax = 2;\r\n\r\n    private projectileColor: string;\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    private imageSourceRect: Rectangle;\r\n\r\n    constructor(projectileImage: HTMLImageElement) {\r\n        this.projectileImage = projectileImage;\r\n        this.worldBounds = window.tileMap.bounds;\r\n\r\n        this.bounds = new Rectangle(0, 0, 24, 24);\r\n        this.velocity = Vector2.empty;\r\n        this.projectileColor = 'black';\r\n        this.imageSourceRect = new Rectangle(0, 0, 32, 32);\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.bounds.update();\r\n        this.updateTTL(delta);\r\n        this.updateVelocity(delta);\r\n    }\r\n\r\n    private updateTTL(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n        this.ttl -= delta;\r\n        if (this.ttl <= 0) {\r\n            this.active = false;\r\n        }\r\n    }\r\n\r\n    private updateVelocity(delta: number): void {\r\n        if (!this.direction || !this.active) {\r\n            return;\r\n        }\r\n        this.velocity.x = this.direction.x * (this.moveSpeed * delta);\r\n        this.velocity.y = this.direction.y * (this.moveSpeed * delta);\r\n\r\n        this.bounds.left += this.velocity.x;\r\n        this.bounds.top += this.velocity.y;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        window.renderEngine.renderImageSource(\r\n            this.projectileImage,\r\n            this.imageSourceRect,\r\n            this.bounds\r\n        );\r\n    }\r\n\r\n    public reset(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        this.active = true;\r\n        this.ttl = this.ttlMax;\r\n        this.startPosition = startPosition;\r\n        this.direction = direction;\r\n        this.moveSpeed = moveSpeed;\r\n\r\n        this.velocity.x = 0;\r\n        this.velocity.y = 0;\r\n\r\n        this.bounds.left = this.startPosition.x - this.bounds.width / 2;\r\n        this.bounds.top = this.startPosition.y - this.bounds.height / 2;\r\n        this.bounds.update();\r\n    }\r\n}\r\n","import { Vector2 } from '../DataObjects/vector2';\r\nimport { Projectile } from './projectile';\r\n\r\nexport class ProjectileEngine {\r\n    public projectiles: Projectile[] = [];\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.projectileImage = window.assetManager.getImage('projectile');\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.update(delta);\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.draw();\r\n        });\r\n    }\r\n\r\n    public activateProjectile(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        let poolSufficient = false;\r\n        for (let i = 0; i < this.projectiles.length; i += 1) {\r\n            if (!this.projectiles[i].active) {\r\n                this.projectiles[i].reset(startPosition, direction, moveSpeed);\r\n                poolSufficient = true;\r\n                // console.log('projectile reset');\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!poolSufficient) {\r\n            this.expandProjectilePool(startPosition, direction, moveSpeed);\r\n        }\r\n    }\r\n\r\n    private expandProjectilePool(\r\n        startPosition: Vector2,\r\n        direction: Vector2,\r\n        moveSpeed: number\r\n    ): Projectile {\r\n        const projectile = new Projectile(this.projectileImage);\r\n        this.projectiles.push(projectile);\r\n        // console.log('grow pool size: ' + this.projectiles.length);\r\n        this.activateProjectile(startPosition, direction, moveSpeed);\r\n        return projectile;\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { EnemySpawner } from '../Enemies/enemySpawner';\r\nimport { LevelManager } from '../Levels/levelManager';\r\nimport { Menu } from '../Menu/menu';\r\nimport { ProjectileEngine } from '../Projectiles/projectileEngine';\r\nimport { Tile } from '../Tiles/tile';\r\nimport { TileMap } from '../Tiles/tileMap';\r\nimport { TowerManager } from '../Towers/towerManager';\r\nimport { SceneInterface } from './scene.interface';\r\n\r\nexport class GameScene implements SceneInterface {\r\n    backgroundImage: HTMLImageElement;\r\n\r\n    tileImage: HTMLImageElement;\r\n\r\n    towerManager: TowerManager;\r\n\r\n    projectileEngine: ProjectileEngine;\r\n\r\n    menu: Menu;\r\n\r\n    newTowerDestinationTile: Tile;\r\n\r\n    // TODO: Abstract into a manager\r\n    collisionCheckElapsed = 0;\r\n\r\n    init(): void {\r\n        this.backgroundImage = window.assetManager.getImage('background');\r\n        this.tileImage = window.assetManager.getImage('tiles');\r\n        window.levelManager = new LevelManager(window.assetManager.levelInfo);\r\n        this.menu = new Menu();\r\n\r\n        window.tileMap = new TileMap(this.tileImage);\r\n        window.enemySpawner = new EnemySpawner();\r\n        this.towerManager = new TowerManager();\r\n        window.projectileEngine = new ProjectileEngine();\r\n\r\n        // TODO: Remove, towers to be added with user input\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[3][3]);\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            this.mouseMove(e.x, e.y);\r\n        });\r\n        window.addEventListener('mousedown', () => {\r\n            this.mouseDown();\r\n        });\r\n        window.addEventListener('mouseup', () => {\r\n            this.mouseUp();\r\n        });\r\n    }\r\n\r\n    update(): void {\r\n        const { delta } = window.gameTime;\r\n        this.checkProjectileEnemyCollision(delta);\r\n\r\n        this.towerManager.update();\r\n        window.enemySpawner.update(delta);\r\n        window.projectileEngine.update(delta);\r\n        this.updateNewTowerDestinationTile();\r\n    }\r\n\r\n    isValidTowerStage(): boolean {\r\n        if (GameScene.isOverMouseMenu()) {\r\n            return false;\r\n        }\r\n        if (!GameScene.isOverGameBounds()) {\r\n            return false;\r\n        }\r\n        if (!this.menu.hasStagedTower) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    updateNewTowerDestinationTile(): void {\r\n        if (!this.isValidTowerStage()) {\r\n            return;\r\n        }\r\n\r\n        const x = Math.floor(window.mouseInfo.x / window.tileMap.tileWidth);\r\n        const y = Math.floor(\r\n            (window.mouseInfo.y - window.tileMap.tileHeight) / window.tileMap.tileHeight\r\n        );\r\n\r\n        if (x < 0 || y < 0) {\r\n            return;\r\n        }\r\n\r\n        this.newTowerDestinationTile = window.tileMap.tileMatrix[y][x];\r\n    }\r\n\r\n    // TODO: Abstract into a manager\r\n    private checkProjectileEnemyCollision(delta: number): void {\r\n        // TODO: Reduce the rate at which collision check is done\r\n        //       This saves browser performance but is less accurate,\r\n        //       missing some collisions.\r\n        this.collisionCheckElapsed += delta;\r\n        if (this.collisionCheckElapsed <= 0.001) {\r\n            return;\r\n        }\r\n        this.collisionCheckElapsed = 0;\r\n        window.enemySpawner.enemies.forEach(enemy => {\r\n            window.projectileEngine.projectiles.forEach(projectile => {\r\n                if (\r\n                    projectile.active &&\r\n                    enemy.active &&\r\n                    enemy.bounds.containsRect(projectile.bounds)\r\n                ) {\r\n                    enemy.hit();\r\n                    projectile.active = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.clearRect(window.tileMap.bounds);\r\n        window.tileMap.draw();\r\n\r\n        // TODO:\r\n        // Create abstraction into animated text rendering.\r\n        window.renderEngine.renderText(\r\n            window.levelManager.currentLevel.levelName,\r\n            64,\r\n            32,\r\n            'red',\r\n            32,\r\n            'impact'\r\n        );\r\n\r\n        window.enemySpawner.draw();\r\n        window.projectileEngine.draw();\r\n        this.towerManager.draw();\r\n        this.menu.draw();\r\n        this.renderOccupiedTiles();\r\n    }\r\n\r\n    renderOccupiedTiles(): void {\r\n        if (!this.isValidTowerStage()) {\r\n            return;\r\n        }\r\n\r\n        const destBounds = this.newTowerDestinationTile\r\n            ? this.newTowerDestinationTile.bounds\r\n            : Rectangle.empty;\r\n\r\n        if (!this.towerManager.isTileEmpty(destBounds)) {\r\n            window.renderEngine.renderRect(destBounds, 'red', true);\r\n        }\r\n    }\r\n\r\n    static isOverMouseMenu(): boolean {\r\n        const menuBounds = GameScene.getElementBounds('tower_menu');\r\n        return menuBounds.containsRect(new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1));\r\n    }\r\n\r\n    static isOverGameBounds(): boolean {\r\n        return window.tileMap.bounds.containsRect(\r\n            new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1)\r\n        );\r\n    }\r\n\r\n    static getElementBounds(elementId: string): Rectangle {\r\n        const element = document.getElementById(elementId);\r\n        return new Rectangle(\r\n            element.clientLeft,\r\n            element.clientTop,\r\n            element.clientWidth,\r\n            element.clientHeight\r\n        );\r\n    }\r\n\r\n    mouseDown(): void {\r\n        if (this.menu.hasStagedTower) {\r\n            return;\r\n        }\r\n\r\n        const mouseRect = new Rectangle(\r\n            window.mouseInfo.x,\r\n            window.mouseInfo.y - this.menu.menuHeight,\r\n            1,\r\n            1\r\n        );\r\n        this.towerManager.mouseDown(mouseRect);\r\n    }\r\n\r\n    mouseUp(): void {\r\n        if (!this.isValidTowerStage()) {\r\n            return;\r\n        }\r\n\r\n        if (this.towerManager.isTileEmpty(this.newTowerDestinationTile.bounds)) {\r\n            this.menu.clearStagedTower();\r\n            this.towerManager.createTower(this.newTowerDestinationTile);\r\n        }\r\n    }\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class LoadScene implements SceneInterface {\r\n    private loadScreenRect: Rectangle;\r\n\r\n    private loadingText: string;\r\n\r\n    constructor() {\r\n        this.loadScreenRect = window.gameConfig.loadScreenRect;\r\n    }\r\n\r\n    init(): void {}\r\n\r\n    update(): void {\r\n        this.loadingText = `${window.assetManager.loadedAssetCount}/${window.assetManager.totalAssets}`;\r\n        window.assetManager.update();\r\n        if (window.assetManager.loadCompleted) {\r\n            window.sceneManager.toggleActiveScene(Scenes.game);\r\n        }\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.renderText(this.loadingText, 0, 0, 'blue', 30, 'impact');\r\n        window.renderEngine.renderRect(this.loadScreenRect, 'black', true);\r\n    }\r\n\r\n    mouseDown(): void {}\r\n\r\n    mouseUp(): void {}\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { GameScene } from './gameScene';\r\nimport { LoadScene } from './loadScene';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class SceneManager {\r\n    private currentScene: SceneInterface;\r\n\r\n    private loadScene: LoadScene;\r\n\r\n    private gameScene: GameScene;\r\n\r\n    constructor() {\r\n        // TODO:\r\n        // Inject depependencies, no initialization\r\n        this.loadScene = new LoadScene();\r\n        this.gameScene = new GameScene();\r\n    }\r\n\r\n    public toggleActiveScene(newScene: Scenes): void {\r\n        if (newScene === Scenes.loading) {\r\n            this.currentScene = this.loadScene;\r\n        }\r\n\r\n        if (newScene === Scenes.game) {\r\n            this.currentScene = this.gameScene;\r\n        }\r\n\r\n        this.currentScene.init();\r\n    }\r\n\r\n    public update(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.update();\r\n        }\r\n    }\r\n\r\n    public render(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.render();\r\n        }\r\n    }\r\n}\r\n","export enum Scenes {\r\n    loading,\r\n    game\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\n\r\nexport class Tile {\r\n    public bounds: Rectangle;\r\n\r\n    private imageObject: ImageObject;\r\n\r\n    private fontSize = 12;\r\n\r\n    constructor(bounds: Rectangle, imageObject: ImageObject) {\r\n        this.bounds = bounds;\r\n        this.imageObject = imageObject;\r\n    }\r\n\r\n    public draw(col: number, row: number): void {\r\n        window.renderEngine.renderImageSource(\r\n            this.imageObject.image,\r\n            this.imageObject.sourceRectangle,\r\n            this.imageObject.destinationRectangle\r\n        );\r\n\r\n        // this.gameScene.renderEngine.renderText(\r\n        //     col + '_' + row,\r\n        //     this.bounds.left,\r\n        //     this.bounds.top + this.fontSize,\r\n        //     'black',\r\n        //     this.fontSize,\r\n        //     'Calibri');\r\n    }\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\nimport { Tile } from './tile';\r\n\r\nexport class TileMap {\r\n    public wayPoints: any = [];\r\n\r\n    public tileMatrix: Tile[][];\r\n\r\n    public rows = window.gameConfig.tileMapRows;\r\n\r\n    public cols = window.gameConfig.tileMapCols;\r\n\r\n    public tileWidth = window.gameConfig.tileMapTileWidth;\r\n\r\n    public tileHeight = window.gameConfig.tileMapTileHeight;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private tileImage: HTMLImageElement;\r\n\r\n    private waterTileImageObject: ImageObject;\r\n\r\n    private pathTileImageObject: ImageObject;\r\n\r\n    constructor(tileImage: HTMLImageElement) {\r\n        this.tileImage = tileImage;\r\n\r\n        this.initTileMatrix();\r\n        this.bounds = new Rectangle(0, 0, this.cols * this.tileWidth, this.rows * this.tileHeight);\r\n    }\r\n\r\n    private initTileMatrix(): void {\r\n        // TODO:\r\n        // Read matrix data from configurable file\r\n        const matrix = [\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 1, 1, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\r\n        ];\r\n\r\n        this.wayPoints = [\r\n            { x: 0, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: 0, y: 2 },\r\n            { x: 1, y: 2 },\r\n            { x: 2, y: 2 },\r\n            { x: 2, y: 3 },\r\n            { x: 2, y: 4 },\r\n            { x: 3, y: 4 },\r\n            { x: 4, y: 4 },\r\n            { x: 4, y: 3 },\r\n            { x: 4, y: 2 },\r\n            { x: 5, y: 2 },\r\n            { x: 6, y: 2 },\r\n            { x: 6, y: 3 },\r\n            { x: 6, y: 4 },\r\n            { x: 6, y: 5 },\r\n            { x: 6, y: 6 },\r\n            { x: 5, y: 6 },\r\n            { x: 4, y: 6 },\r\n            { x: 4, y: 7 },\r\n            { x: 4, y: 8 },\r\n            { x: 5, y: 8 },\r\n            { x: 5, y: 9 },\r\n            { x: 6, y: 9 },\r\n            { x: 7, y: 9 },\r\n            { x: 8, y: 9 },\r\n            { x: 9, y: 9 }\r\n        ];\r\n\r\n        this.tileMatrix = [];\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            this.tileMatrix[row] = [];\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                const matrixValue = matrix[row][col];\r\n                const tileImageObject = this.getTileImageObject(\r\n                    matrixValue,\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row\r\n                );\r\n\r\n                // TODO:\r\n                // Tile should provide underlying imageObject with coordinates and size values.\r\n                // Abstract source rectangle values into \"tilesSpriteSheet\" configuration.\r\n                const tileBounds = new Rectangle(\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row,\r\n                    this.tileWidth,\r\n                    this.tileHeight\r\n                );\r\n                // console.log('col:' + col + ' row:' + row)\r\n                this.tileMatrix[row][col] = new Tile(tileBounds, tileImageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getTileImageObject(\r\n        matrixValue: number,\r\n        destinationX: number,\r\n        destinationY: number\r\n    ): ImageObject {\r\n        const tileImageObject = new ImageObject();\r\n        tileImageObject.image = this.tileImage;\r\n        tileImageObject.x = destinationX;\r\n        tileImageObject.y = destinationY;\r\n        tileImageObject.width = this.tileWidth;\r\n        tileImageObject.height = this.tileHeight;\r\n        tileImageObject.swidth = 32;\r\n        tileImageObject.sheight = 32;\r\n\r\n        if (matrixValue === 0) {\r\n            tileImageObject.sx = 0;\r\n            tileImageObject.sy = 0;\r\n        } else {\r\n            tileImageObject.sx = 32;\r\n            tileImageObject.sy = 0;\r\n        }\r\n\r\n        return tileImageObject;\r\n    }\r\n\r\n    public draw(): void {\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                this.tileMatrix[row][col].draw(col, row);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\nimport { Enemy } from '../Enemies/enemy';\r\nimport { Tile } from '../Tiles/tile';\r\n\r\nexport abstract class BaseTower {\r\n    public shootRange = 20000;\r\n\r\n    public targetInRange: boolean;\r\n\r\n    public targetDirection: Vector2;\r\n\r\n    public destinationTile: Tile;\r\n\r\n    public target: Enemy;\r\n\r\n    public center: Vector2;\r\n\r\n    private rotation = 0;\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    private selected = false;\r\n\r\n    private southAngle = 180;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        this.destinationTile = destinationTile;\r\n        this.towerImage = towerImage;\r\n\r\n        this.center = Vector2.empty;\r\n    }\r\n\r\n    public update(): void {\r\n        this.center.x = this.destinationTile.bounds.getCenterWidth;\r\n        this.center.y = this.destinationTile.bounds.getCenterHeight;\r\n        this.destinationTile.bounds.update();\r\n\r\n        this.updateTarget();\r\n        this.updateTargetInRange();\r\n        this.updateRotation();\r\n    }\r\n\r\n    public draw(): void {\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 32, 32);\r\n\r\n        window.renderEngine.renderRotatedImageSource(\r\n            this.towerImage,\r\n            sourceRectangle,\r\n            this.destinationTile.bounds,\r\n            this.rotation\r\n        );\r\n\r\n        if (this.selected) {\r\n            this.drawRange();\r\n            this.drawSelection();\r\n        }\r\n    }\r\n\r\n    public setSelection(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    private drawRange(): void {\r\n        window.renderEngine.renderEllipse(\r\n            this.center.x,\r\n            this.center.y,\r\n            'red',\r\n            0.5,\r\n            this.shootRange,\r\n            false\r\n        );\r\n    }\r\n\r\n    private drawSelection(): void {\r\n        window.renderEngine.renderEllipse(\r\n            this.center.x,\r\n            this.center.y,\r\n            'yellow',\r\n            0.5,\r\n            this.destinationTile.bounds.height,\r\n            true\r\n        );\r\n    }\r\n\r\n    private updateTargetInRange(): void {\r\n        if (this.target != null && this.target.active) {\r\n            this.targetDirection = this.center.subtract(this.target.center);\r\n            const distance = this.targetDirection.magnitude();\r\n            if (distance <= this.shootRange) {\r\n                this.targetInRange = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.targetInRange = false;\r\n    }\r\n\r\n    private updateRotation(): void {\r\n        // Rotate the tower towards it's current target or\r\n        // rotate to default position if no target exist or if target not in range.\r\n\r\n        // Apperantly rotaion can be negative value. e.g. -100\r\n        // This depends on which direction the tower moves\r\n        // e.g. start at 0 move clockwise results in positive value 0 to 360\r\n        // e.g. start at 0 move counter clockwise results in negative value 0 to -360\r\n\r\n        // The rotation value can also get greater than 360 of smaller that -360\r\n        // thus we have to stop and reset rotation at these points\r\n\r\n        if (!this.target) {\r\n            if (this.rotation < -90 && this.rotation > -270) {\r\n                // Reset rotation by moving tower counter clockwise\r\n                this.rotation -= 1.5;\r\n            } else if (this.rotation > -180 && this.rotation < 0) {\r\n                // Reset rotation by moving tower clockwise\r\n                this.rotation += 1.5;\r\n            } else {\r\n                // NOTE: rotational north is -270\r\n                // Ideally this should be 0 or 360 but havent found where this is being set.\r\n                this.rotation = -270;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.targetInRange) {\r\n            this.calculateRotation(\r\n                new Vector2(\r\n                    this.target.center.x - this.center.x,\r\n                    this.target.center.y - this.center.y\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    private calculateRotation(distance: Vector2): void {\r\n        this.rotation = Math.atan2(distance.y, distance.x) * (180 / Math.PI) - 180;\r\n    }\r\n\r\n    private updateTarget(): void {\r\n        let distance = 0;\r\n        let closestDistance = 99999;\r\n        let closestEnemy: Enemy;\r\n\r\n        const livingEnemies = window.enemySpawner.enemies.filter(e => e.active);\r\n        for (let e = 0; e < livingEnemies.length; e += 1) {\r\n            const enemy = livingEnemies[e];\r\n            distance = enemy.center.distance(this.center);\r\n\r\n            if (distance < closestDistance || closestEnemy == null) {\r\n                closestDistance = distance;\r\n                closestEnemy = enemy;\r\n            }\r\n        }\r\n\r\n        this.target = closestEnemy;\r\n    }\r\n}\r\n","import { Vector2 } from '../DataObjects/vector2';\r\nimport { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\n\r\nexport class PlainTower extends BaseTower {\r\n    private plainTowerShootSpeed = window.gameConfig.plainTowerShootSpeed;\r\n\r\n    private plainTowerShootRate = window.gameConfig.plainTowerShootRate;\r\n\r\n    private shootElapsed = 0;\r\n\r\n    private accuracyEnabled = true;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        super(destinationTile, towerImage);\r\n        super.shootRange = window.gameConfig.plainTowerShootRange;\r\n    }\r\n\r\n    public update(): void {\r\n        super.update();\r\n\r\n        this.updateShoot();\r\n    }\r\n\r\n    private updateShoot(): void {\r\n        const { delta } = window.gameTime;\r\n        this.shootElapsed += delta;\r\n        if (this.targetInRange && this.shootElapsed >= this.plainTowerShootRate) {\r\n            this.shootElapsed = 0;\r\n            let direction = Vector2.empty;\r\n\r\n            if (this.accuracyEnabled) {\r\n                direction = this.target.futurePosition.subtract(this.center);\r\n            } else {\r\n                direction = this.target.center.subtract(this.center);\r\n            }\r\n\r\n            const normalizedDirection = direction.normalize();\r\n            window.projectileEngine.activateProjectile(\r\n                this.center,\r\n                normalizedDirection,\r\n                this.plainTowerShootSpeed\r\n            );\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        super.draw();\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\nimport { PlainTower } from './plainTower';\r\n\r\nexport class TowerManager {\r\n    public towers: BaseTower[] = [];\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.towerImage = window.assetManager.getImage('towerplain');\r\n    }\r\n\r\n    public update(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.update();\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.draw();\r\n        });\r\n    }\r\n\r\n    public isTileEmpty(tileBounds: Rectangle): boolean {\r\n        const tileEmpty =\r\n            this.towers.filter(\r\n                t =>\r\n                    t.destinationTile.bounds.left === tileBounds.left &&\r\n                    t.destinationTile.bounds.top === tileBounds.top\r\n            ).length === 0;\r\n        return tileEmpty;\r\n    }\r\n\r\n    public createTower(destinationTile: Tile): void {\r\n        this.towers.push(new PlainTower(destinationTile, this.towerImage));\r\n    }\r\n\r\n    public mouseDown(mouseRect: Rectangle): void {\r\n        this.selectTower(mouseRect);\r\n    }\r\n\r\n    private selectTower(mouseRect: Rectangle): void {\r\n        let visibleInfo = false;\r\n        let selectedTower: BaseTower = null;\r\n\r\n        for (let i = 0; i < this.towers.length; i += 1) {\r\n            const tower = this.towers[i];\r\n            if (tower.destinationTile.bounds.containsRect(mouseRect)) {\r\n                tower.setSelection(true);\r\n                visibleInfo = true;\r\n                selectedTower = tower;\r\n            } else {\r\n                tower.setSelection(false);\r\n            }\r\n        }\r\n\r\n        TowerManager.setSelectionInfo(visibleInfo, selectedTower);\r\n    }\r\n\r\n    static setSelectionInfo(visible: boolean, selectedTower: BaseTower): void {\r\n        const infoPane = document.getElementById('info_pane');\r\n\r\n        if (visible) {\r\n            infoPane.classList.remove('hidden');\r\n        } else {\r\n            infoPane.classList.add('hidden');\r\n            return;\r\n        }\r\n\r\n        if (selectedTower) {\r\n            const infoImg = document.getElementById('info_img') as HTMLImageElement;\r\n            // TODO: Once more tower types are added, use type to find correct tower image.\r\n            infoImg.src = window.assetManager.getImage('towerplain').src;\r\n\r\n            // TODO: Once more tower types are added, use type to find correct tower text.\r\n            const infoText = document.getElementById('info_text');\r\n            infoText.innerText = 'Plain Tower';\r\n        }\r\n    }\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\nimport { Vector2 } from './DataObjects/vector2';\r\n\r\nexport class GameConfig {\r\n    public canvasWidth = 480;\r\n\r\n    public canvasHeight = 480;\r\n\r\n    public backgroundBounds = new Rectangle(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    public loadScreenRect = new Rectangle(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    public tileMapRows = 10;\r\n\r\n    public tileMapCols = 10;\r\n\r\n    public tileMapTileWidth = 48;\r\n\r\n    public tileMapTileHeight = 48;\r\n\r\n    public plainTowerShootSpeed = 250;\r\n\r\n    public plainTowerShootRate = 0.7;\r\n\r\n    public plainTowerShootRange = 150;\r\n\r\n    public enemyFuturePositionModifier = 20;\r\n\r\n    public menuStagedTowerImageWidth = 48;\r\n\r\n    public menuStagedTowerImageHeight = 48;\r\n\r\n    public enemySize = new Vector2(48, 48);\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\n\r\nexport class RenderEngine {\r\n    private context: CanvasRenderingContext2D;\r\n\r\n    constructor() {\r\n        const gameCanvas = document.getElementById('game-canvas') as HTMLCanvasElement;\r\n        this.context = gameCanvas.getContext('2d');\r\n    }\r\n\r\n    public clearRect(rect: Rectangle): void {\r\n        if (rect) {\r\n            this.context.clearRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n    }\r\n\r\n    public renderRect(rect: Rectangle, color: string, fill: boolean): void {\r\n        const originalFillStyle = this.context.fillStyle;\r\n        const originalStrokeStyle = this.context.strokeStyle;\r\n\r\n        if (fill) {\r\n            this.context.fillStyle = color;\r\n            this.context.fillRect(rect.left, rect.top, rect.width, rect.height);\r\n        } else {\r\n            this.context.beginPath();\r\n            this.context.strokeStyle = color;\r\n            this.context.strokeRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n\r\n        this.context.fillStyle = originalFillStyle;\r\n        this.context.strokeStyle = originalStrokeStyle;\r\n    }\r\n\r\n    public renderText(\r\n        text: string,\r\n        x: number,\r\n        y: number,\r\n        color: string,\r\n        fontSize: number,\r\n        fontFamily: string\r\n    ): void {\r\n        this.context.fillStyle = color;\r\n        this.context.font = `${fontSize}px ${fontFamily}`;\r\n        this.context.fillText(text, x, y);\r\n    }\r\n\r\n    public renderImageRect(image: HTMLImageElement, bounds: Rectangle): void {\r\n        this.renderImage(image, bounds.left, bounds.top, bounds.width, bounds.height);\r\n    }\r\n\r\n    public renderImage(\r\n        image: HTMLImageElement,\r\n        x: number,\r\n        y: number,\r\n        width: number = null,\r\n        height: number = null\r\n    ): void {\r\n        const w = width == null ? image.width : width;\r\n        const h = height == null ? image.height : height;\r\n        this.context.drawImage(image, x, y, w, h);\r\n    }\r\n\r\n    public renderImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle\r\n    ): void {\r\n        if (\r\n            sourceRect.left < 0 ||\r\n            sourceRect.top < 0 ||\r\n            sourceRect.height <= 0 ||\r\n            sourceRect.height <= 0\r\n        ) {\r\n            return;\r\n        }\r\n        this.context.drawImage(\r\n            image,\r\n            sourceRect.left,\r\n            sourceRect.top,\r\n            sourceRect.width,\r\n            sourceRect.height,\r\n            destRect.left,\r\n            destRect.top,\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n    }\r\n\r\n    public renderRotatedImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle,\r\n        rotation = 0\r\n    ): void {\r\n        this.context.save();\r\n        this.context.translate(destRect.getCenterWidth, destRect.getCenterHeight);\r\n        this.context.rotate((rotation - 90) * (Math.PI / 180));\r\n\r\n        const rotatedDestRect = new Rectangle(\r\n            -(destRect.width / 2),\r\n            -(destRect.height / 2),\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n\r\n        this.renderImageSource(image, sourceRect, rotatedDestRect);\r\n\r\n        this.context.restore();\r\n    }\r\n\r\n    public renderEllipse(\r\n        centerX: number,\r\n        centerY: number,\r\n        color: string,\r\n        opacity: number,\r\n        radius: number,\r\n        fill: boolean\r\n    ): void {\r\n        this.context.save();\r\n        this.context.globalAlpha = opacity;\r\n        this.context.strokeStyle = color;\r\n        this.context.beginPath();\r\n        this.context.ellipse(centerX, centerY, radius, radius, Math.PI / 4, 0, 2 * Math.PI);\r\n\r\n        if (fill) {\r\n            this.context.fill();\r\n        } else {\r\n            this.context.stroke();\r\n        }\r\n        this.context.restore();\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AssetManager } from './AssetLoading/assetManager';\r\nimport { GameTime } from './DataObjects/gameTime';\r\nimport { GameConfig } from './gameConfig';\r\nimport { RenderEngine } from './renderEngine';\r\nimport { SceneInterface } from './Scenes/scene.interface';\r\nimport { SceneManager } from './Scenes/sceneManager';\r\nimport { Scenes } from './Scenes/scenes.enum';\r\n\r\nexport class Game {\r\n    public assetManager: AssetManager;\r\n\r\n    public currentScene: SceneInterface;\r\n\r\n    private running: boolean;\r\n\r\n    constructor() {\r\n        window.gameConfig = new GameConfig();\r\n        window.renderEngine = new RenderEngine();\r\n        window.assetManager = new AssetManager();\r\n        window.assetManager.init();\r\n        window.sceneManager = new SceneManager();\r\n        window.sceneManager.toggleActiveScene(Scenes.loading);\r\n        window.gameTime = new GameTime();\r\n        window.mouseInfo = { x: 0, y: 0 };\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            Game.mouseMove(e);\r\n        });\r\n    }\r\n\r\n    public start(): void {\r\n        if (this.running) {\r\n            return;\r\n        }\r\n\r\n        this.running = true;\r\n        this.loop();\r\n    }\r\n\r\n    private loop(): void {\r\n        window.gameTime.update();\r\n\r\n        if (window.sceneManager) {\r\n            window.sceneManager.update();\r\n            window.sceneManager.render();\r\n        }\r\n\r\n        requestAnimationFrame(() => this.loop());\r\n    }\r\n\r\n    static mouseMove(event: any): void {\r\n        window.mouseInfo = { x: event.x, y: event.y };\r\n    }\r\n}\r\n\r\nwindow.addEventListener('load', () => {\r\n    const game = new Game();\r\n    game.start();\r\n});\r\n"],"names":["images","levelInfo","init","this","levelInfoLoaded","loadCompleted","totalAssets","initAssets","request","XMLHttpRequest","onload","status","data","JSON","parse","responseText","assetCount","initImages","imageAssets","initLevelInfo","levelInfoFile","open","send","forEach","asset","image","ImageAsset","key","src","push","img","console","error","update","loadedAssetCount","filter","x","loaded","length","getImage","at","constructor","Image","delta","previousLoopTime","Date","now","currentTime","sourceRect","destinationRect","sourceRectangle","Rectangle","sx","sy","swidth","sheight","destinationRectangle","y","width","height","left","top","updateRight","right","updateBottom","bottom","intersectRect","rectangle","containsRect","getCenterWidth","getCenterHeight","clone","equals","rect","toString","empty","Vector2","subtract","vector2","distance","Math","sqrt","magnitude","normalize","normalX","normalY","Number","isNaN","enemyImage","wayPointReachedThreshold","moveSpeed","hp","maxHp","topPadding","hpRemainingBarColor","hpFullBarColor","alive","originalWayPoints","window","tileMap","wayPoints","reset","active","movementWayPoints","slice","movements","up","down","position","futurePosition","size","gameConfig","enemySize","center","velocity","bounds","nextMovePoint","hpBounds","liveBounds","enemyName","random","onLastWaypoint","firstWayPoint","shift","waypointBounds","tileMatrix","updateBounds","updateHpBounds","direction","distanceFromNextWaypoint","nextWaypointReached","dispatchEvent","CustomEvent","nextWayPoint","normalizedDirection","setMoveDirection","applyVelocity","updateLifeBounds","enemyFuturePositionModifier","percentageDiff","percentageLive","draw","renderEngine","renderImageSource","drawRemainingHPBar","drawFullHPBar","renderRect","hit","enemies","enemySpawnCount","enemySpawnElapsed","enemiesKilled","enemiesEscaped","assetManager","setCurrentLevel","addEventListener","enemy","updateSpawner","updateRoundCheck","enemySpawnCountMax","enemySpawnRate","createEnemy","levelManager","currentLevel","nextLevel","Enemy","enemyMoveSpeed","enemyMaxHp","loadLevel","index","levelIndex","l","stagedTowerImageWidth","menuStagedTowerImageWidth","stagedTowerImageHeight","menuStagedTowerImageHeight","hasStagedTower","towerClicked","menuHeight","document","getElementById","clientHeight","imageDictionary","clearStagedTower","stagedTower","type","mouseInfo","tX","tY","find","renderImage","projectileImage","ttl","ttlMax","worldBounds","projectileColor","imageSourceRect","updateTTL","updateVelocity","startPosition","projectiles","projectile","activateProjectile","poolSufficient","i","expandProjectilePool","Projectile","GameScene","collisionCheckElapsed","backgroundImage","tileImage","LevelManager","menu","Menu","TileMap","enemySpawner","EnemySpawner","towerManager","TowerManager","projectileEngine","ProjectileEngine","createTower","e","mouseMove","mouseDown","mouseUp","gameTime","checkProjectileEnemyCollision","updateNewTowerDestinationTile","isValidTowerStage","isOverMouseMenu","isOverGameBounds","floor","tileWidth","tileHeight","newTowerDestinationTile","render","clearRect","renderText","levelName","renderOccupiedTiles","destBounds","isTileEmpty","static","getElementBounds","elementId","element","clientLeft","clientTop","clientWidth","mouseRect","resize","loadScreenRect","loadingText","sceneManager","toggleActiveScene","Scenes","game","loadScene","LoadScene","gameScene","newScene","loading","currentScene","imageObject","fontSize","col","row","rows","tileMapRows","cols","tileMapCols","tileMapTileWidth","tileMapTileHeight","initTileMatrix","matrix","matrixValue","tileImageObject","getTileImageObject","tileBounds","Tile","destinationX","destinationY","ImageObject","destinationTile","towerImage","shootRange","rotation","selected","southAngle","updateTarget","updateTargetInRange","updateRotation","renderRotatedImageSource","drawRange","drawSelection","setSelection","renderEllipse","target","targetDirection","targetInRange","calculateRotation","atan2","PI","closestEnemy","closestDistance","livingEnemies","PlainTower","BaseTower","super","plainTowerShootSpeed","plainTowerShootRate","shootElapsed","accuracyEnabled","plainTowerShootRange","updateShoot","towers","tower","t","selectTower","visibleInfo","selectedTower","setSelectionInfo","visible","infoPane","classList","remove","innerText","add","canvasWidth","canvasHeight","backgroundBounds","gameCanvas","context","getContext","color","fill","originalFillStyle","fillStyle","originalStrokeStyle","strokeStyle","fillRect","beginPath","strokeRect","text","fontFamily","font","fillText","renderImageRect","w","h","drawImage","destRect","save","translate","rotate","rotatedDestRect","restore","centerX","centerY","opacity","radius","globalAlpha","ellipse","stroke","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","Game","GameConfig","RenderEngine","AssetManager","SceneManager","GameTime","start","running","loop","requestAnimationFrame","event"],"sourceRoot":""}