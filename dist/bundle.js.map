{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://towers/./src/AssetLoading/assetManager.ts","webpack://towers/./src/AssetLoading/imageAsset.ts","webpack://towers/./src/DataObjects/gameTime.ts","webpack://towers/./src/DataObjects/imageObject.ts","webpack://towers/./src/DataObjects/rectangle.ts","webpack://towers/./src/DataObjects/vector2.ts","webpack://towers/./src/Enemies/enemy.ts","webpack://towers/./src/Enemies/enemySpawner.ts","webpack://towers/./src/Levels/levelManager.ts","webpack://towers/./src/Menu/menu.ts","webpack://towers/./src/Projectiles/projectile.ts","webpack://towers/./src/Projectiles/projectileEngine.ts","webpack://towers/./src/Scenes/gameScene.ts","webpack://towers/./src/Scenes/loadScene.ts","webpack://towers/./src/Scenes/sceneManager.ts","webpack://towers/./src/Scenes/scenes.enum.ts","webpack://towers/./src/Tiles/tile.ts","webpack://towers/./src/Tiles/tileMap.ts","webpack://towers/./src/Towers/baseTower.ts","webpack://towers/./src/Towers/plainTower.ts","webpack://towers/./src/Towers/towerManager.ts","webpack://towers/./src/gameConfig.ts","webpack://towers/./src/renderEngine.ts","webpack://towers/webpack/bootstrap","webpack://towers/./src/game.ts"],"sourcesContent":["import { Level } from '../Levels/level';\r\nimport { ImageAsset } from './imageAsset';\r\n\r\nexport class AssetManager {\r\n    images: ImageAsset[] = [];\r\n\r\n    levelInfo: Level[] = [];\r\n\r\n    levelInfoLoaded: boolean;\r\n\r\n    totalAssets: number;\r\n\r\n    public loadedAssetCount: number;\r\n\r\n    public loadCompleted: boolean;\r\n\r\n    init(): void {\r\n        this.levelInfoLoaded = false;\r\n        this.loadCompleted = false;\r\n        this.totalAssets = 0;\r\n        this.initAssets();\r\n    }\r\n\r\n    initAssets(): void {\r\n        const request = new XMLHttpRequest();\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.totalAssets = data.assetCount;\r\n                this.initImages(data.imageAssets);\r\n                this.initLevelInfo(data.levelInfoFile);\r\n            }\r\n        };\r\n        request.open('get', './assets/assetManifest.json', true);\r\n        request.send();\r\n    }\r\n\r\n    initImages(imageAssets: any): void {\r\n        imageAssets.forEach(asset => {\r\n            const image = new ImageAsset(asset.key, asset.src);\r\n            this.images.push(image);\r\n        });\r\n\r\n        this.images.forEach(img => {\r\n            img.init();\r\n        });\r\n    }\r\n\r\n    initLevelInfo(levelInfoFile: string): void {\r\n        if (!levelInfoFile) {\r\n            console.error('no level info file provided');\r\n            return;\r\n        }\r\n\r\n        const request = new XMLHttpRequest();\r\n\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.levelInfo = data;\r\n                this.levelInfoLoaded = true;\r\n            }\r\n        };\r\n        request.open('get', levelInfoFile, true);\r\n        request.send();\r\n    }\r\n\r\n    update(): void {\r\n        this.loadedAssetCount = this.images.filter(x => x.loaded).length;\r\n        this.loadedAssetCount = this.levelInfoLoaded\r\n            ? (this.loadedAssetCount += 1)\r\n            : this.loadedAssetCount;\r\n\r\n        if (this.totalAssets !== 0 && this.totalAssets === this.loadedAssetCount) {\r\n            this.loadCompleted = true;\r\n        }\r\n    }\r\n\r\n    getImage(key: string): HTMLImageElement {\r\n        return this.images.filter(x => x.key === key).at(0).image;\r\n    }\r\n}\r\n","export class ImageAsset {\r\n    public loaded: boolean;\r\n\r\n    public image: HTMLImageElement;\r\n\r\n    public key: string;\r\n\r\n    src: string;\r\n\r\n    constructor(key: string, src: string) {\r\n        this.loaded = false;\r\n        this.key = key;\r\n        this.src = src;\r\n    }\r\n\r\n    init(): void {\r\n        this.image = new Image();\r\n        this.image.onload = (): void => {\r\n            this.loaded = true;\r\n        };\r\n        this.image.src = this.src;\r\n    }\r\n}\r\n","export class GameTime {\r\n    public delta = 0;\r\n\r\n    private previousLoopTime: number = Date.now();\r\n\r\n    public update(): void {\r\n        const currentTime = Date.now();\r\n        const delta = currentTime - this.previousLoopTime;\r\n        this.delta = delta / 1000;\r\n        this.previousLoopTime = currentTime;\r\n    }\r\n}\r\n","import { Rectangle } from './rectangle';\r\n\r\nexport class ImageObject {\r\n    public image: HTMLImageElement;\r\n\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    public sx: number;\r\n\r\n    public sy: number;\r\n\r\n    public swidth: number;\r\n\r\n    public sheight: number;\r\n\r\n    private sourceRect: Rectangle = null;\r\n\r\n    private destinationRect: Rectangle = null;\r\n\r\n    public get sourceRectangle(): Rectangle {\r\n        if (this.sourceRect == null) {\r\n            this.sourceRect = new Rectangle(this.sx, this.sy, this.swidth, this.sheight);\r\n        }\r\n\r\n        return this.sourceRect;\r\n    }\r\n\r\n    public get destinationRectangle(): Rectangle {\r\n        if (this.destinationRect == null) {\r\n            this.destinationRect = new Rectangle(this.x, this.y, this.width, this.height);\r\n        }\r\n\r\n        return this.destinationRect;\r\n    }\r\n}\r\n","export class Rectangle {\r\n    public left: number;\r\n\r\n    public top: number;\r\n\r\n    public bottom: number;\r\n\r\n    public right: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    constructor(left: number, top: number, width: number, height: number) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.update();\r\n    }\r\n\r\n    private updateRight(): void {\r\n        this.right = this.left + this.width;\r\n    }\r\n\r\n    private updateBottom(): void {\r\n        this.bottom = this.top + this.height;\r\n    }\r\n\r\n    public update(): void {\r\n        this.updateRight();\r\n        this.updateBottom();\r\n    }\r\n\r\n    public intersectRect(rectangle: Rectangle): boolean {\r\n        return !(\r\n            rectangle.left > this.right ||\r\n            rectangle.right < this.left ||\r\n            rectangle.top > this.bottom ||\r\n            rectangle.bottom < this.top\r\n        );\r\n    }\r\n\r\n    public containsRect(rectangle: Rectangle): boolean {\r\n        return (\r\n            this.left <= rectangle.left &&\r\n            rectangle.right <= this.right &&\r\n            this.top <= rectangle.top &&\r\n            rectangle.bottom <= this.bottom\r\n        );\r\n    }\r\n\r\n    public get getCenterWidth(): number {\r\n        this.updateRight();\r\n        return this.right - this.width / 2;\r\n    }\r\n\r\n    public get getCenterHeight(): number {\r\n        this.updateBottom();\r\n        return this.bottom - this.height / 2;\r\n    }\r\n\r\n    public clone(): Rectangle {\r\n        return new Rectangle(this.left, this.top, this.width, this.height);\r\n    }\r\n\r\n    public equals(rect: Rectangle): boolean {\r\n        return (\r\n            this.left == rect.left &&\r\n            this.top == rect.top &&\r\n            this.width == rect.width &&\r\n            this.height == rect.height\r\n        );\r\n    }\r\n\r\n    public toString(): string {\r\n        return `x:${this.left} y: ${this.top} w: ${this.width} h:${this.height}`;\r\n    }\r\n}\r\n","export class Vector2 {\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public subtract(vector2: Vector2): Vector2 {\r\n        return new Vector2(this.x - vector2.x, this.y - vector2.y);\r\n    }\r\n\r\n    public distance(vector2: Vector2): number {\r\n        const x = (this.x - vector2.x) * (this.x - vector2.x);\r\n        const y = (this.y - vector2.y) * (this.y - vector2.y);\r\n        return Math.sqrt(x + y);\r\n    }\r\n\r\n    public magnitude(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    public normalize(): Vector2 {\r\n        const distance = Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n        const normalX = this.x / distance;\r\n        const normalY = this.y / distance;\r\n\r\n        return new Vector2(\r\n            Number.isNaN(normalX) ? 0 : normalX,\r\n            Number.isNaN(normalY) ? 0 : normalY\r\n        );\r\n    }\r\n\r\n    static get empty(): Vector2 {\r\n        return new Vector2(0, 0);\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Enemy {\r\n    public position: Vector2;\r\n\r\n    public size: Vector2;\r\n\r\n    public active: boolean;\r\n\r\n    public center: Vector2;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    public futurePosition: Vector2;\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private originalWayPoints: any;\r\n\r\n    private movementWayPoints: any;\r\n\r\n    private wayPointReachedThreshold = 2;\r\n\r\n    private movements: any;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private nextMovePoint: Vector2;\r\n\r\n    private normalizedDirection: Vector2;\r\n\r\n    private distanceFromNextWaypoint: number;\r\n\r\n    private moveSpeed = 75;\r\n\r\n    private hp = 0;\r\n\r\n    private maxHp = 5;\r\n\r\n    private hpBounds: Rectangle;\r\n\r\n    private liveBounds: Rectangle;\r\n\r\n    private topPadding = 10;\r\n\r\n    private hpRemainingBarColor = 'red';\r\n\r\n    private hpFullBarColor = 'green';\r\n\r\n    private enemyName: string;\r\n\r\n    private alive = false;\r\n\r\n    constructor(enemyImage: HTMLImageElement) {\r\n        this.enemyImage = enemyImage;\r\n        this.originalWayPoints = window.tileMap.wayPoints;\r\n        this.reset(0, 0);\r\n    }\r\n\r\n    public reset(moveSpeed: number, maxHp: number): void {\r\n        this.active = false;\r\n        this.alive = false;\r\n        this.maxHp = maxHp;\r\n        this.hp = this.maxHp;\r\n        this.moveSpeed = moveSpeed;\r\n        this.movementWayPoints = this.originalWayPoints.slice();\r\n        this.movements = { left: false, right: false, up: false, down: false };\r\n        this.position = Vector2.empty;\r\n        this.futurePosition = Vector2.empty;\r\n        this.size = new Vector2(48, 48);\r\n        this.center = Vector2.empty;\r\n        this.velocity = Vector2.empty;\r\n        this.bounds = new Rectangle(0, 0, 0, 0);\r\n        this.nextMovePoint = null;\r\n        this.hpBounds = new Rectangle(\r\n            this.bounds.left,\r\n            this.bounds.top - this.topPadding,\r\n            this.bounds.width,\r\n            this.bounds.height\r\n        );\r\n        this.liveBounds = this.hpBounds.clone();\r\n        this.enemyName = Math.random().toString();\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        let onLastWaypoint = false;\r\n        if (this.movementWayPoints.length <= 0) {\r\n            onLastWaypoint = true;\r\n        }\r\n\r\n        if (!this.nextMovePoint) {\r\n            const firstWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds =\r\n                window.tileMap.tileMatrix[firstWayPoint.y][firstWayPoint.x].bounds;\r\n            this.nextMovePoint = new Vector2(\r\n                waypointBounds.getCenterWidth,\r\n                waypointBounds.getCenterHeight\r\n            );\r\n        }\r\n\r\n        this.updateBounds();\r\n        this.updateHpBounds();\r\n\r\n        this.direction = this.nextMovePoint.subtract(this.center);\r\n        this.distanceFromNextWaypoint = this.direction.magnitude();\r\n\r\n        if (this.nextWaypointReached()) {\r\n            if (onLastWaypoint) {\r\n                this.nextMovePoint = null;\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': end reached');\r\n                window.dispatchEvent(new CustomEvent('enemyReachedEnd'));\r\n                return;\r\n            }\r\n            const nextWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds = window.tileMap.tileMatrix[nextWayPoint.y][nextWayPoint.x].bounds;\r\n            this.nextMovePoint.x = waypointBounds.getCenterWidth;\r\n            this.nextMovePoint.y = waypointBounds.getCenterHeight;\r\n            this.direction = this.center.subtract(this.nextMovePoint);\r\n        }\r\n\r\n        this.normalizedDirection = this.direction.normalize();\r\n        if (\r\n            !Number.isNaN(this.normalizedDirection.x) &&\r\n            !Number.isNaN(this.normalizedDirection.y)\r\n        ) {\r\n            this.velocity.x = this.normalizedDirection.x * (this.moveSpeed * delta);\r\n            this.velocity.y = this.normalizedDirection.y * (this.moveSpeed * delta);\r\n            this.setMoveDirection();\r\n        }\r\n\r\n        this.applyVelocity();\r\n    }\r\n\r\n    private nextWaypointReached(): boolean {\r\n        return this.distanceFromNextWaypoint < this.wayPointReachedThreshold;\r\n    }\r\n\r\n    private updateBounds(): void {\r\n        this.bounds.left = this.position.x;\r\n        this.bounds.top = this.position.y;\r\n        this.bounds.width = this.size.x;\r\n        this.bounds.height = this.size.y;\r\n        this.bounds.update();\r\n\r\n        this.updateHpBounds();\r\n        this.updateLifeBounds();\r\n\r\n        this.center.x = this.bounds.getCenterWidth;\r\n        this.center.y = this.bounds.getCenterHeight;\r\n\r\n        this.futurePosition.x = this.center.x;\r\n        this.futurePosition.y = this.center.y;\r\n\r\n        this.futurePosition.x =\r\n            this.center.x + this.velocity.x * window.gameConfig.enemyFuturePositionModifier;\r\n        this.futurePosition.y =\r\n            this.center.y + this.velocity.y * window.gameConfig.enemyFuturePositionModifier;\r\n    }\r\n\r\n    private updateHpBounds(): void {\r\n        const percentageRemaining = (this.hp * 100) / this.maxHp;\r\n        const percentageDiff = 100 - percentageRemaining;\r\n\r\n        const percentageLive = (this.liveBounds.width * percentageDiff) / 100;\r\n        this.hpBounds.width = this.liveBounds.width - percentageLive;\r\n\r\n        this.hpBounds.left = this.bounds.left;\r\n        this.hpBounds.top = this.bounds.top;\r\n        this.hpBounds.height = this.bounds.height / this.topPadding;\r\n        this.hpBounds.update();\r\n    }\r\n\r\n    private updateLifeBounds(): void {\r\n        this.liveBounds.left = this.bounds.left;\r\n        this.liveBounds.top = this.bounds.top;\r\n        this.liveBounds.width = this.bounds.width;\r\n        this.liveBounds.height = this.bounds.height / this.topPadding;\r\n        this.liveBounds.update();\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 68, 80);\r\n\r\n        window.renderEngine.renderImageSource(this.enemyImage, sourceRectangle, this.bounds);\r\n\r\n        // TODO:\r\n        // Introduce damage percentage bar\r\n        this.drawRemainingHPBar();\r\n        this.drawFullHPBar();\r\n    }\r\n\r\n    private drawRemainingHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.liveBounds, this.hpRemainingBarColor, true);\r\n    }\r\n\r\n    private drawFullHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.hpBounds, this.hpFullBarColor, true);\r\n    }\r\n\r\n    private setMoveDirection(): void {\r\n        this.movements.left = this.velocity.x < 0;\r\n        this.movements.right = this.velocity.x > 0;\r\n\r\n        this.movements.up = this.velocity.y < 0;\r\n        this.movements.down = this.velocity.y > 0;\r\n\r\n        if (\r\n            (this.movements.left || this.movements.right) &&\r\n            (this.movements.up || this.movements.down)\r\n        ) {\r\n            // We detect if both horizontal and vertical movement is set.\r\n            // As we can only play one animation per axis movement we should determine\r\n            // what axis has the greater velocity value and use that as the direction.\r\n\r\n            const horizontalValue = this.velocity.x < 0 ? this.velocity.x * -1 : this.velocity.x;\r\n\r\n            const verticalValue = this.velocity.y < 0 ? this.velocity.y * -1 : this.velocity.y;\r\n\r\n            if (horizontalValue > verticalValue) {\r\n                this.movements.left = this.velocity.x < 0;\r\n                this.movements.right = this.velocity.x > 0;\r\n                this.movements.up = false;\r\n                this.movements.down = false;\r\n            } else {\r\n                this.movements.up = this.velocity.y < 0;\r\n                this.movements.down = this.velocity.y > 0;\r\n                this.movements.left = false;\r\n                this.movements.right = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyVelocity(): void {\r\n        this.position.x += this.velocity.x;\r\n        this.position.y += this.velocity.y;\r\n    }\r\n\r\n    public hit(): void {\r\n        if (this.active) {\r\n            this.hp -= 1;\r\n            // console.log(this.enemyName + ': hit ' + this.hp);\r\n\r\n            if (this.hp <= 0) {\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': killed');\r\n                window.dispatchEvent(new CustomEvent('enemyKilled'));\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Enemy } from './enemy';\r\n\r\nexport class EnemySpawner {\r\n    public enemies: Enemy[] = [];\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private enemySpawnCount = 0;\r\n\r\n    private enemySpawnCountMax: number;\r\n\r\n    private enemySpawnRate: number;\r\n\r\n    private enemySpawnElapsed = 0;\r\n\r\n    private enemiesKilled = 0;\r\n\r\n    private enemiesEscaped = 0;\r\n\r\n    constructor() {\r\n        this.enemyImage = window.assetManager.getImage('squid');\r\n        this.setCurrentLevel();\r\n\r\n        window.addEventListener('enemyKilled', () => {\r\n            this.enemiesKilled += 1;\r\n        });\r\n        window.addEventListener('enemyReachedEnd', () => {\r\n            this.enemiesEscaped += 1;\r\n        });\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.update(delta);\r\n        });\r\n\r\n        this.updateSpawner(delta);\r\n        this.updateRoundCheck();\r\n    }\r\n\r\n    private updateSpawner(delta: number): void {\r\n        if (this.enemySpawnCount >= this.enemySpawnCountMax) {\r\n            return;\r\n        }\r\n        this.enemySpawnElapsed += delta;\r\n        if (this.enemySpawnElapsed >= this.enemySpawnRate) {\r\n            this.enemySpawnElapsed = 0;\r\n            this.createEnemy();\r\n            this.enemySpawnCount += 1;\r\n        }\r\n    }\r\n\r\n    private updateRoundCheck(): void {\r\n        if (\r\n            this.enemiesEscaped + this.enemiesKilled ===\r\n            window.levelManager.currentLevel.enemySpawnCountMax\r\n        ) {\r\n            this.enemiesKilled = 0;\r\n            this.enemiesEscaped = 0;\r\n            this.enemySpawnCount = 0;\r\n            window.levelManager.nextLevel();\r\n            this.setCurrentLevel();\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.draw();\r\n        });\r\n    }\r\n\r\n    public createEnemy(): void {\r\n        // TODO:\r\n        // Reset inactive enemies from pool instead of creating new ones\r\n        // THIS IS A LEAK BTW\r\n        // console.clear();\r\n        // console.log(\"enemy in array count: \" + this.enemies.length);\r\n\r\n        const enemy = new Enemy(this.enemyImage);\r\n        enemy.reset(\r\n            window.levelManager.currentLevel.enemyMoveSpeed,\r\n            window.levelManager.currentLevel.enemyMaxHp\r\n        );\r\n        enemy.active = true;\r\n        this.enemies.push(enemy);\r\n    }\r\n\r\n    private setCurrentLevel(): void {\r\n        this.enemySpawnCountMax = window.levelManager.currentLevel.enemySpawnCountMax;\r\n        this.enemySpawnRate = window.levelManager.currentLevel.enemySpawnRate;\r\n    }\r\n}\r\n","import { Level } from './level';\r\n\r\nexport class LevelManager {\r\n    private levelInfo: Level[];\r\n\r\n    public currentLevel: Level;\r\n\r\n    constructor(levelInfo: Level[]) {\r\n        this.levelInfo = levelInfo;\r\n        this.loadLevel();\r\n    }\r\n\r\n    private loadLevel(): void {\r\n        if (this.currentLevel == null) {\r\n            this.currentLevel = this.levelInfo.at(0);\r\n        }\r\n    }\r\n\r\n    public nextLevel(): void {\r\n        const index = this.currentLevel.levelIndex + 1;\r\n        for (let l = 0; l < this.levelInfo.length; l += 1) {\r\n            if (this.levelInfo[l].levelIndex === index) {\r\n                this.currentLevel = this.levelInfo[l];\r\n                return;\r\n            }\r\n        }\r\n\r\n        // NOTE: If we get here, no more level exist\r\n        // TODO:\r\n        // Raise end of level notification\r\n        // console.log(\"last level done\")\r\n    }\r\n}\r\n","import { ImageKeyPair } from '../Types/imageKeyPair';\r\n\r\nexport class Menu {\r\n    public stagedTowerImageWidth = 48;\r\n\r\n    public stagedTowerImageHeight = 48;\r\n\r\n    private imageDictionary: ImageKeyPair[];\r\n\r\n    private stagedTower: string;\r\n\r\n    private menuHeight: number;\r\n\r\n    constructor() {\r\n        window.addEventListener('plainTowerClicked', () => {\r\n            this.towerClicked('plain');\r\n        });\r\n        window.addEventListener('slowTowerClicked', () => {\r\n            this.towerClicked('slow');\r\n        });\r\n        this.menuHeight = document.getElementById('tower_menu').clientHeight;\r\n\r\n        this.imageDictionary = [\r\n            { key: 'plain', image: window.assetManager.getImage('towerplain') },\r\n            { key: 'slow', image: window.assetManager.getImage('towerslow') }\r\n        ];\r\n    }\r\n\r\n    public clearStagedTower(): void {\r\n        this.stagedTower = '';\r\n    }\r\n\r\n    private towerClicked(type: string): void {\r\n        this.stagedTower = type;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!window.mouseInfo || !this.stagedTower) {\r\n            return;\r\n        }\r\n\r\n        const tX = window.mouseInfo.x - this.stagedTowerImageWidth / 2;\r\n        const tY = window.mouseInfo.y - this.stagedTowerImageHeight / 2 - this.menuHeight;\r\n\r\n        const { image } = this.imageDictionary.find(x => x.key === this.stagedTower);\r\n        window.renderEngine.renderImage(\r\n            image,\r\n            tX,\r\n            tY,\r\n            this.stagedTowerImageWidth,\r\n            this.stagedTowerImageHeight\r\n        );\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Projectile {\r\n    public active = false;\r\n\r\n    private startPosition: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private worldBounds: Rectangle;\r\n\r\n    private inWorldBounds: boolean;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private moveSpeed = 0.5;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private ttl = 0;\r\n\r\n    private ttlMax = 2;\r\n\r\n    private projectileColor: string;\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    private imageSourceRect: Rectangle;\r\n\r\n    constructor(projectileImage: HTMLImageElement) {\r\n        this.projectileImage = projectileImage;\r\n        this.worldBounds = window.tileMap.bounds;\r\n\r\n        this.bounds = new Rectangle(0, 0, 24, 24);\r\n        this.velocity = Vector2.empty;\r\n        this.projectileColor = 'black';\r\n        this.imageSourceRect = new Rectangle(0, 0, 32, 32);\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.bounds.update();\r\n        this.updateTTL(delta);\r\n        this.updateVelocity(delta);\r\n    }\r\n\r\n    private updateTTL(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n        this.ttl -= delta;\r\n        if (this.ttl <= 0) {\r\n            this.active = false;\r\n        }\r\n    }\r\n\r\n    private updateVelocity(delta: number): void {\r\n        if (!this.direction || !this.active) {\r\n            return;\r\n        }\r\n        this.velocity.x = this.direction.x * (this.moveSpeed * delta);\r\n        this.velocity.y = this.direction.y * (this.moveSpeed * delta);\r\n\r\n        this.bounds.left += this.velocity.x;\r\n        this.bounds.top += this.velocity.y;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        window.renderEngine.renderImageSource(\r\n            this.projectileImage,\r\n            this.imageSourceRect,\r\n            this.bounds\r\n        );\r\n    }\r\n\r\n    public reset(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        this.active = true;\r\n        this.ttl = this.ttlMax;\r\n        this.startPosition = startPosition;\r\n        this.direction = direction;\r\n        this.moveSpeed = moveSpeed;\r\n\r\n        this.velocity.x = 0;\r\n        this.velocity.y = 0;\r\n\r\n        this.bounds.left = this.startPosition.x - this.bounds.width / 2;\r\n        this.bounds.top = this.startPosition.y - this.bounds.height / 2;\r\n        this.bounds.update();\r\n    }\r\n}\r\n","import { Vector2 } from '../DataObjects/vector2';\r\nimport { Projectile } from './projectile';\r\n\r\nexport class ProjectileEngine {\r\n    public projectiles: Projectile[] = [];\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.projectileImage = window.assetManager.getImage('projectile');\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.update(delta);\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.draw();\r\n        });\r\n    }\r\n\r\n    public activateProjectile(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        let poolSufficient = false;\r\n        for (let i = 0; i < this.projectiles.length; i += 1) {\r\n            if (!this.projectiles[i].active) {\r\n                this.projectiles[i].reset(startPosition, direction, moveSpeed);\r\n                poolSufficient = true;\r\n                // console.log('projectile reset');\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!poolSufficient) {\r\n            this.expandProjectilePool(startPosition, direction, moveSpeed);\r\n        }\r\n    }\r\n\r\n    private expandProjectilePool(\r\n        startPosition: Vector2,\r\n        direction: Vector2,\r\n        moveSpeed: number\r\n    ): Projectile {\r\n        const projectile = new Projectile(this.projectileImage);\r\n        this.projectiles.push(projectile);\r\n        // console.log('grow pool size: ' + this.projectiles.length);\r\n        this.activateProjectile(startPosition, direction, moveSpeed);\r\n        return projectile;\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { EnemySpawner } from '../Enemies/enemySpawner';\r\nimport { LevelManager } from '../Levels/levelManager';\r\nimport { Menu } from '../Menu/menu';\r\nimport { ProjectileEngine } from '../Projectiles/projectileEngine';\r\nimport { TileMap } from '../Tiles/tileMap';\r\nimport { TowerManager } from '../Towers/towerManager';\r\nimport { SceneInterface } from './scene.interface';\r\n\r\nexport class GameScene implements SceneInterface {\r\n    backgroundImage: HTMLImageElement;\r\n\r\n    tileImage: HTMLImageElement;\r\n\r\n    towerManager: TowerManager;\r\n\r\n    projectileEngine: ProjectileEngine;\r\n\r\n    menu: Menu;\r\n\r\n    // TODO: Abstract into a manager\r\n    collisionCheckElapsed = 0;\r\n\r\n    init(): void {\r\n        this.backgroundImage = window.assetManager.getImage('background');\r\n        this.tileImage = window.assetManager.getImage('tiles');\r\n        window.levelManager = new LevelManager(window.assetManager.levelInfo);\r\n        this.menu = new Menu();\r\n\r\n        window.tileMap = new TileMap(this.tileImage);\r\n        window.enemySpawner = new EnemySpawner();\r\n        this.towerManager = new TowerManager();\r\n        window.projectileEngine = new ProjectileEngine();\r\n\r\n        // TODO: Remove, towers to be added with user input\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[3][3]);\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[5][5]);\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[8][7]);\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            this.mouseMove(e.x, e.y);\r\n        });\r\n        window.addEventListener('mousedown', () => {\r\n            this.mouseDown();\r\n        });\r\n        window.addEventListener('mouseup', () => {\r\n            this.mouseUp();\r\n        });\r\n    }\r\n\r\n    update(): void {\r\n        const { delta } = window.gameTime;\r\n        this.checkProjectileEnemyCollision(delta);\r\n\r\n        this.towerManager.update();\r\n        window.enemySpawner.update(delta);\r\n        window.projectileEngine.update(delta);\r\n    }\r\n\r\n    // TODO: Abstract into a manager\r\n    private checkProjectileEnemyCollision(delta: number): void {\r\n        // TODO: Reduce the rate at which collision check is done\r\n        //       This saves browser performance but is less accurate,\r\n        //       missing some collisions.\r\n        this.collisionCheckElapsed += delta;\r\n        if (this.collisionCheckElapsed <= 0.001) {\r\n            return;\r\n        }\r\n        this.collisionCheckElapsed = 0;\r\n        window.enemySpawner.enemies.forEach(enemy => {\r\n            window.projectileEngine.projectiles.forEach(projectile => {\r\n                if (\r\n                    projectile.active &&\r\n                    enemy.active &&\r\n                    enemy.bounds.containsRect(projectile.bounds)\r\n                ) {\r\n                    enemy.hit();\r\n                    projectile.active = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.clearRect(window.tileMap.bounds);\r\n        window.tileMap.draw();\r\n\r\n        // TODO:\r\n        // Create abstraction into animated text rendering.\r\n        window.renderEngine.renderText(\r\n            window.levelManager.currentLevel.levelName,\r\n            64,\r\n            32,\r\n            'red',\r\n            32,\r\n            'impact'\r\n        );\r\n\r\n        window.enemySpawner.draw();\r\n        this.towerManager.draw();\r\n        window.projectileEngine.draw();\r\n        this.menu.draw();\r\n    }\r\n\r\n    static isOverMouseMenu(): boolean {\r\n        const menuBounds = GameScene.getElementBounds('tower_menu');\r\n        return menuBounds.containsRect(new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1));\r\n    }\r\n\r\n    static isOverGameBounds(): boolean {\r\n        return window.tileMap.bounds.containsRect(\r\n            new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1)\r\n        );\r\n    }\r\n\r\n    static getElementBounds(elementId: string): Rectangle {\r\n        const element = document.getElementById(elementId);\r\n        return new Rectangle(\r\n            element.clientLeft,\r\n            element.clientTop,\r\n            element.clientWidth,\r\n            element.clientHeight\r\n        );\r\n    }\r\n\r\n    mouseDown(): void {}\r\n\r\n    mouseUp(): void {\r\n        if (GameScene.isOverMouseMenu()) {\r\n            return;\r\n        }\r\n        if (!GameScene.isOverGameBounds()) {\r\n            return;\r\n        }\r\n\r\n        const x = Math.floor(window.mouseInfo.x / window.tileMap.tileWidth);\r\n        const y = Math.floor(\r\n            (window.mouseInfo.y - window.tileMap.tileHeight) / window.tileMap.tileHeight\r\n        );\r\n        const destinationTile = window.tileMap.tileMatrix[y][x];\r\n        this.menu.clearStagedTower();\r\n        this.towerManager.createTower(destinationTile);\r\n\r\n        console.log(\r\n            `tileX:${x} tileY:${y} destTile:${destinationTile.bounds} mouseX:${window.mouseInfo.x} mouseY:${window.mouseInfo.y}`\r\n        );\r\n    }\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class LoadScene implements SceneInterface {\r\n    private loadScreenRect: Rectangle;\r\n\r\n    private loadingText: string;\r\n\r\n    constructor() {\r\n        this.loadScreenRect = new Rectangle(0, 0, 800, 480);\r\n    }\r\n\r\n    init(): void {}\r\n\r\n    update(): void {\r\n        this.loadingText = `${window.assetManager.loadedAssetCount}/${window.assetManager.totalAssets}`;\r\n        window.assetManager.update();\r\n        if (window.assetManager.loadCompleted) {\r\n            window.sceneManager.toggleActiveScene(Scenes.game);\r\n        }\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.renderText(this.loadingText, 0, 0, 'blue', 30, 'impact');\r\n        window.renderEngine.renderRect(this.loadScreenRect, 'black', true);\r\n    }\r\n\r\n    mouseDown(): void {}\r\n\r\n    mouseUp(): void {}\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { GameScene } from './gameScene';\r\nimport { LoadScene } from './loadScene';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class SceneManager {\r\n    private currentScene: SceneInterface;\r\n\r\n    private loadScene: LoadScene;\r\n\r\n    private gameScene: GameScene;\r\n\r\n    constructor() {\r\n        // TODO:\r\n        // Inject depependencies, no initialization\r\n        this.loadScene = new LoadScene();\r\n        this.gameScene = new GameScene();\r\n    }\r\n\r\n    public toggleActiveScene(newScene: Scenes): void {\r\n        if (newScene === Scenes.loading) {\r\n            this.currentScene = this.loadScene;\r\n        }\r\n\r\n        if (newScene === Scenes.game) {\r\n            this.currentScene = this.gameScene;\r\n        }\r\n\r\n        this.currentScene.init();\r\n    }\r\n\r\n    public update(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.update();\r\n        }\r\n    }\r\n\r\n    public render(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.render();\r\n        }\r\n    }\r\n}\r\n","export enum Scenes {\r\n    loading,\r\n    game\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\n\r\nexport class Tile {\r\n    public bounds: Rectangle;\r\n\r\n    private imageObject: ImageObject;\r\n\r\n    private fontSize = 12;\r\n\r\n    constructor(bounds: Rectangle, imageObject: ImageObject) {\r\n        this.bounds = bounds;\r\n        this.imageObject = imageObject;\r\n    }\r\n\r\n    public draw(col: number, row: number): void {\r\n        window.renderEngine.renderImageSource(\r\n            this.imageObject.image,\r\n            this.imageObject.sourceRectangle,\r\n            this.imageObject.destinationRectangle\r\n        );\r\n\r\n        // this.gameScene.renderEngine.renderText(\r\n        //     col + '_' + row,\r\n        //     this.bounds.left,\r\n        //     this.bounds.top + this.fontSize,\r\n        //     'black',\r\n        //     this.fontSize,\r\n        //     'Calibri');\r\n    }\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\nimport { Tile } from './tile';\r\n\r\nexport class TileMap {\r\n    public wayPoints: any = [];\r\n\r\n    public tileMatrix: Tile[][];\r\n\r\n    public rows = window.gameConfig.tileMapRows;\r\n\r\n    public cols = window.gameConfig.tileMapCols;\r\n\r\n    public tileWidth = window.gameConfig.tileMapTileWidth;\r\n\r\n    public tileHeight = window.gameConfig.tileMapTileHeight;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private tileImage: HTMLImageElement;\r\n\r\n    private waterTileImageObject: ImageObject;\r\n\r\n    private pathTileImageObject: ImageObject;\r\n\r\n    constructor(tileImage: HTMLImageElement) {\r\n        this.tileImage = tileImage;\r\n\r\n        this.initTileMatrix();\r\n        this.bounds = new Rectangle(0, 0, this.cols * this.tileWidth, this.rows * this.tileHeight);\r\n    }\r\n\r\n    private initTileMatrix(): void {\r\n        // TODO:\r\n        // Read matrix data from configurable file\r\n        const matrix = [\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 1, 1, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\r\n        ];\r\n\r\n        this.wayPoints = [\r\n            { x: 0, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: 0, y: 2 },\r\n            { x: 1, y: 2 },\r\n            { x: 2, y: 2 },\r\n            { x: 2, y: 3 },\r\n            { x: 2, y: 4 },\r\n            { x: 3, y: 4 },\r\n            { x: 4, y: 4 },\r\n            { x: 4, y: 3 },\r\n            { x: 4, y: 2 },\r\n            { x: 5, y: 2 },\r\n            { x: 6, y: 2 },\r\n            { x: 6, y: 3 },\r\n            { x: 6, y: 4 },\r\n            { x: 6, y: 5 },\r\n            { x: 6, y: 6 },\r\n            { x: 5, y: 6 },\r\n            { x: 4, y: 6 },\r\n            { x: 4, y: 7 },\r\n            { x: 4, y: 8 },\r\n            { x: 5, y: 8 },\r\n            { x: 5, y: 9 },\r\n            { x: 6, y: 9 },\r\n            { x: 7, y: 9 },\r\n            { x: 8, y: 9 },\r\n            { x: 9, y: 9 }\r\n        ];\r\n\r\n        this.tileMatrix = [];\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            this.tileMatrix[row] = [];\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                const matrixValue = matrix[row][col];\r\n                const tileImageObject = this.getTileImageObject(\r\n                    matrixValue,\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row\r\n                );\r\n\r\n                // TODO:\r\n                // Tile should provide underlying imageObject with coordinates and size values.\r\n                // Abstract source rectangle values into \"tilesSpriteSheet\" configuration.\r\n                const tileBounds = new Rectangle(\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row,\r\n                    this.tileWidth,\r\n                    this.tileHeight\r\n                );\r\n                // console.log('col:' + col + ' row:' + row)\r\n                this.tileMatrix[row][col] = new Tile(tileBounds, tileImageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getTileImageObject(\r\n        matrixValue: number,\r\n        destinationX: number,\r\n        destinationY: number\r\n    ): ImageObject {\r\n        const tileImageObject = new ImageObject();\r\n        tileImageObject.image = this.tileImage;\r\n        tileImageObject.x = destinationX;\r\n        tileImageObject.y = destinationY;\r\n        tileImageObject.width = this.tileWidth;\r\n        tileImageObject.height = this.tileHeight;\r\n        tileImageObject.swidth = 32;\r\n        tileImageObject.sheight = 32;\r\n\r\n        if (matrixValue === 0) {\r\n            tileImageObject.sx = 0;\r\n            tileImageObject.sy = 0;\r\n        } else {\r\n            tileImageObject.sx = 32;\r\n            tileImageObject.sy = 0;\r\n        }\r\n\r\n        return tileImageObject;\r\n    }\r\n\r\n    public draw(): void {\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                this.tileMatrix[row][col].draw(col, row);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\nimport { Enemy } from '../Enemies/enemy';\r\nimport { Tile } from '../Tiles/tile';\r\n\r\nexport abstract class BaseTower {\r\n    public shootRange = 20000;\r\n\r\n    public targetInRange: boolean;\r\n\r\n    public targetDirection: Vector2;\r\n\r\n    public destinationTile: Tile;\r\n\r\n    public target: Enemy;\r\n\r\n    public center: Vector2;\r\n\r\n    private rotation = 0;\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    private selected: boolean;\r\n\r\n    private southAngle = 180;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        this.destinationTile = destinationTile;\r\n        this.towerImage = towerImage;\r\n\r\n        this.center = Vector2.empty;\r\n    }\r\n\r\n    public update(): void {\r\n        this.center.x = this.destinationTile.bounds.getCenterWidth;\r\n        this.center.y = this.destinationTile.bounds.getCenterHeight;\r\n        this.destinationTile.bounds.update();\r\n\r\n        this.updateTarget();\r\n        this.updateTargetInRange();\r\n        this.updateRotation();\r\n    }\r\n\r\n    public draw(): void {\r\n        this.drawRange();\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 32, 32);\r\n\r\n        window.renderEngine.renderRotatedImageSource(\r\n            this.towerImage,\r\n            sourceRectangle,\r\n            this.destinationTile.bounds,\r\n            this.rotation\r\n        );\r\n\r\n        this.drawSelection();\r\n    }\r\n\r\n    public setSelection(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    private drawRange(): void {\r\n        window.renderEngine.renderEllipse(\r\n            this.center.x,\r\n            this.center.y,\r\n            'red',\r\n            0.5,\r\n            this.shootRange,\r\n            false\r\n        );\r\n    }\r\n\r\n    private drawSelection(): void {\r\n        // TODO:\r\n        // Draw any overlay selection effects\r\n    }\r\n\r\n    private updateTargetInRange(): void {\r\n        if (this.target != null && this.target.active) {\r\n            this.targetDirection = this.center.subtract(this.target.center);\r\n            // console.log('target direction  y: ' + this.targetDirection.x + ' y: ' + this.targetDirection.y);\r\n            const distance = this.targetDirection.magnitude();\r\n            if (distance <= this.shootRange) {\r\n                // console.log('ranged');\r\n                this.targetInRange = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.targetInRange = false;\r\n    }\r\n\r\n    private updateRotation(): void {\r\n        // Rotate the tower towards it's current target or\r\n        // rotate to default position if no target exist or if target not in range.\r\n\r\n        // Apperantly rotaion can be negative value. e.g. -100\r\n        // This depends on which direction the tower moves\r\n        // e.g. start at 0 move clockwise results in positive value 0 to 360\r\n        // e.g. start at 0 move counter clockwise results in negative value 0 to -360\r\n\r\n        // The rotation value can also get greater than 360 of smaller that -360\r\n        // thus we have to stop and reset rotation at these points\r\n\r\n        if (this.targetInRange) {\r\n            const xDistance = this.target.center.x - this.center.x;\r\n            const yDistance = this.target.center.y - this.center.y;\r\n\r\n            // TODO: update tower image to point north, then reduce below starting angle calculation\r\n            this.rotation = Math.atan2(yDistance, xDistance) * (180 / Math.PI) - 270;\r\n        } else if (this.rotation < -180 && this.rotation > -360) {\r\n            // Reset rotaion by moving tower counter clockwise\r\n            this.rotation -= 1.5;\r\n        } else if (this.rotation > -180 && this.rotation < 1) {\r\n            // Reset rotaion by moving tower clockwise\r\n            this.rotation += 1.5;\r\n        } else {\r\n            this.rotation = 0;\r\n        }\r\n    }\r\n\r\n    private updateTarget(): void {\r\n        let distance = 0;\r\n        let closestDistance = 99999;\r\n        let closestEnemy: Enemy;\r\n\r\n        const livingEnemies = window.enemySpawner.enemies.filter(e => e.active);\r\n        for (let e = 0; e < livingEnemies.length; e += 1) {\r\n            const enemy = livingEnemies[e];\r\n            distance = enemy.center.distance(this.center);\r\n\r\n            if (distance < closestDistance || closestEnemy == null) {\r\n                closestDistance = distance;\r\n                closestEnemy = enemy;\r\n            }\r\n        }\r\n\r\n        this.target = closestEnemy;\r\n    }\r\n}\r\n","import { Vector2 } from '../DataObjects/vector2';\r\nimport { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\n\r\nexport class PlainTower extends BaseTower {\r\n    private plainTowerShootSpeed = window.gameConfig.plainTowerShootSpeed;\r\n\r\n    private plainTowerShootRate = window.gameConfig.plainTowerShootRate;\r\n\r\n    private shootElapsed = 0;\r\n\r\n    private accuracyEnabled = true;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        super(destinationTile, towerImage);\r\n        super.shootRange = window.gameConfig.plainTowerShootRange;\r\n    }\r\n\r\n    public update(): void {\r\n        super.update();\r\n\r\n        this.updateShoot();\r\n    }\r\n\r\n    private updateShoot(): void {\r\n        const { delta } = window.gameTime;\r\n        this.shootElapsed += delta;\r\n        if (this.targetInRange && this.shootElapsed >= this.plainTowerShootRate) {\r\n            this.shootElapsed = 0;\r\n            let direction = Vector2.empty;\r\n\r\n            if (this.accuracyEnabled) {\r\n                direction = this.target.futurePosition.subtract(this.center);\r\n            } else {\r\n                direction = this.target.center.subtract(this.center);\r\n            }\r\n\r\n            const normalizedDirection = direction.normalize();\r\n            window.projectileEngine.activateProjectile(\r\n                this.center,\r\n                normalizedDirection,\r\n                this.plainTowerShootSpeed\r\n            );\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        super.draw();\r\n    }\r\n}\r\n","import { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\nimport { PlainTower } from './plainTower';\r\n\r\nexport class TowerManager {\r\n    public towers: BaseTower[] = [];\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.towerImage = window.assetManager.getImage('towerplain');\r\n    }\r\n\r\n    public update(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.update();\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.draw();\r\n        });\r\n    }\r\n\r\n    public createTower(destinationTile: Tile): void {\r\n        this.towers.push(new PlainTower(destinationTile, this.towerImage));\r\n    }\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\n\r\nexport class GameConfig {\r\n    public canvasWidth = 960;\r\n\r\n    public canvasHeight = 960;\r\n\r\n    public backgroundBounds = new Rectangle(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    public tileMapRows = 10;\r\n\r\n    public tileMapCols = 10;\r\n\r\n    public tileMapTileWidth = 96;\r\n\r\n    public tileMapTileHeight = 96;\r\n\r\n    public plainTowerShootSpeed = 250;\r\n\r\n    public plainTowerShootRate = 0.7;\r\n\r\n    public plainTowerShootRange = 150;\r\n\r\n    public enemyFuturePositionModifier = 20;\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\n\r\nexport class RenderEngine {\r\n    private context: CanvasRenderingContext2D;\r\n\r\n    constructor() {\r\n        const gameCanvas = document.getElementById('game-canvas') as HTMLCanvasElement;\r\n        this.context = gameCanvas.getContext('2d');\r\n    }\r\n\r\n    public clearRect(rect: Rectangle): void {\r\n        if (rect) {\r\n            this.context.clearRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n    }\r\n\r\n    public renderRect(rect: Rectangle, color: string, fill: boolean): void {\r\n        const originalFillStyle = this.context.fillStyle;\r\n        const originalStrokeStyle = this.context.strokeStyle;\r\n\r\n        if (fill) {\r\n            this.context.fillStyle = color;\r\n            this.context.fillRect(rect.left, rect.top, rect.width, rect.height);\r\n        } else {\r\n            this.context.beginPath();\r\n            this.context.strokeStyle = color;\r\n            this.context.strokeRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n\r\n        this.context.fillStyle = originalFillStyle;\r\n        this.context.strokeStyle = originalStrokeStyle;\r\n    }\r\n\r\n    public renderText(\r\n        text: string,\r\n        x: number,\r\n        y: number,\r\n        color: string,\r\n        fontSize: number,\r\n        fontFamily: string\r\n    ): void {\r\n        this.context.fillStyle = color;\r\n        this.context.font = `${fontSize}px ${fontFamily}`;\r\n        this.context.fillText(text, x, y);\r\n    }\r\n\r\n    public renderImageRect(image: HTMLImageElement, bounds: Rectangle): void {\r\n        this.renderImage(image, bounds.left, bounds.top, bounds.width, bounds.height);\r\n    }\r\n\r\n    public renderImage(\r\n        image: HTMLImageElement,\r\n        x: number,\r\n        y: number,\r\n        width: number = null,\r\n        height: number = null\r\n    ): void {\r\n        const w = width == null ? image.width : width;\r\n        const h = height == null ? image.height : height;\r\n        this.context.drawImage(image, x, y, w, h);\r\n    }\r\n\r\n    public renderImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle\r\n    ): void {\r\n        if (\r\n            sourceRect.left < 0 ||\r\n            sourceRect.top < 0 ||\r\n            sourceRect.height <= 0 ||\r\n            sourceRect.height <= 0\r\n        ) {\r\n            return;\r\n        }\r\n        this.context.drawImage(\r\n            image,\r\n            sourceRect.left,\r\n            sourceRect.top,\r\n            sourceRect.width,\r\n            sourceRect.height,\r\n            destRect.left,\r\n            destRect.top,\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n    }\r\n\r\n    public renderRotatedImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle,\r\n        rotation = 0\r\n    ): void {\r\n        this.context.save();\r\n        this.context.translate(destRect.getCenterWidth, destRect.getCenterHeight);\r\n        this.context.rotate((rotation - 90) * (Math.PI / 180));\r\n\r\n        const rotatedDestRect = new Rectangle(\r\n            -(destRect.width / 2),\r\n            -(destRect.height / 2),\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n\r\n        this.renderImageSource(image, sourceRect, rotatedDestRect);\r\n\r\n        this.context.restore();\r\n    }\r\n\r\n    public renderEllipse(\r\n        centerX: number,\r\n        centerY: number,\r\n        color: string,\r\n        opacity: number,\r\n        radius: number,\r\n        fill: boolean\r\n    ): void {\r\n        this.context.save();\r\n        this.context.globalAlpha = opacity;\r\n        this.context.strokeStyle = color;\r\n        this.context.beginPath();\r\n        this.context.ellipse(centerX, centerY, radius, radius, Math.PI / 4, 0, 2 * Math.PI);\r\n\r\n        if (fill) {\r\n            this.context.fill();\r\n        } else {\r\n            this.context.stroke();\r\n        }\r\n        this.context.restore();\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AssetManager } from './AssetLoading/assetManager';\r\nimport { GameTime } from './DataObjects/gameTime';\r\nimport { GameConfig } from './gameConfig';\r\nimport { RenderEngine } from './renderEngine';\r\nimport { SceneInterface } from './Scenes/scene.interface';\r\nimport { SceneManager } from './Scenes/sceneManager';\r\nimport { Scenes } from './Scenes/scenes.enum';\r\n\r\nexport class Game {\r\n    public assetManager: AssetManager;\r\n\r\n    public currentScene: SceneInterface;\r\n\r\n    private running: boolean;\r\n\r\n    constructor() {\r\n        window.gameConfig = new GameConfig();\r\n        window.renderEngine = new RenderEngine();\r\n        window.assetManager = new AssetManager();\r\n        window.assetManager.init();\r\n        window.sceneManager = new SceneManager();\r\n        window.sceneManager.toggleActiveScene(Scenes.loading);\r\n        window.gameTime = new GameTime();\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            Game.mouseMove(e);\r\n        });\r\n    }\r\n\r\n    public start(): void {\r\n        if (this.running) {\r\n            return;\r\n        }\r\n\r\n        this.running = true;\r\n        this.loop();\r\n    }\r\n\r\n    private loop(): void {\r\n        window.gameTime.update();\r\n\r\n        if (window.sceneManager) {\r\n            window.sceneManager.update();\r\n            window.sceneManager.render();\r\n        }\r\n\r\n        requestAnimationFrame(() => this.loop());\r\n    }\r\n\r\n    static mouseMove(event: any): void {\r\n        window.mouseInfo = { x: event.x, y: event.y };\r\n    }\r\n}\r\n\r\nwindow.addEventListener('load', () => {\r\n    const game = new Game();\r\n    game.start();\r\n});\r\n"],"names":["images","levelInfo","init","this","levelInfoLoaded","loadCompleted","totalAssets","initAssets","request","XMLHttpRequest","onload","status","data","JSON","parse","responseText","assetCount","initImages","imageAssets","initLevelInfo","levelInfoFile","open","send","forEach","asset","image","ImageAsset","key","src","push","img","console","error","update","loadedAssetCount","filter","x","loaded","length","getImage","at","constructor","Image","delta","previousLoopTime","Date","now","currentTime","sourceRect","destinationRect","sourceRectangle","Rectangle","sx","sy","swidth","sheight","destinationRectangle","y","width","height","left","top","updateRight","right","updateBottom","bottom","intersectRect","rectangle","containsRect","getCenterWidth","getCenterHeight","clone","equals","rect","toString","Vector2","subtract","vector2","distance","Math","sqrt","magnitude","normalize","normalX","normalY","Number","isNaN","empty","enemyImage","wayPointReachedThreshold","moveSpeed","hp","maxHp","topPadding","hpRemainingBarColor","hpFullBarColor","alive","originalWayPoints","window","tileMap","wayPoints","reset","active","movementWayPoints","slice","movements","up","down","position","futurePosition","size","center","velocity","bounds","nextMovePoint","hpBounds","liveBounds","enemyName","random","onLastWaypoint","firstWayPoint","shift","waypointBounds","tileMatrix","updateBounds","updateHpBounds","direction","distanceFromNextWaypoint","nextWaypointReached","dispatchEvent","CustomEvent","nextWayPoint","normalizedDirection","setMoveDirection","applyVelocity","updateLifeBounds","gameConfig","enemyFuturePositionModifier","percentageDiff","percentageLive","draw","renderEngine","renderImageSource","drawRemainingHPBar","drawFullHPBar","renderRect","hit","enemies","enemySpawnCount","enemySpawnElapsed","enemiesKilled","enemiesEscaped","assetManager","setCurrentLevel","addEventListener","enemy","updateSpawner","updateRoundCheck","enemySpawnCountMax","enemySpawnRate","createEnemy","levelManager","currentLevel","nextLevel","Enemy","enemyMoveSpeed","enemyMaxHp","loadLevel","index","levelIndex","l","stagedTowerImageWidth","stagedTowerImageHeight","towerClicked","menuHeight","document","getElementById","clientHeight","imageDictionary","clearStagedTower","stagedTower","type","mouseInfo","tX","tY","find","renderImage","projectileImage","ttl","ttlMax","worldBounds","projectileColor","imageSourceRect","updateTTL","updateVelocity","startPosition","projectiles","projectile","activateProjectile","poolSufficient","i","expandProjectilePool","Projectile","GameScene","collisionCheckElapsed","backgroundImage","tileImage","LevelManager","menu","Menu","TileMap","enemySpawner","EnemySpawner","towerManager","TowerManager","projectileEngine","ProjectileEngine","createTower","e","mouseMove","mouseDown","mouseUp","gameTime","checkProjectileEnemyCollision","render","clearRect","renderText","levelName","static","getElementBounds","elementId","element","clientLeft","clientTop","clientWidth","isOverMouseMenu","isOverGameBounds","floor","tileWidth","tileHeight","destinationTile","log","resize","loadScreenRect","loadingText","sceneManager","toggleActiveScene","Scenes","game","loadScene","LoadScene","gameScene","newScene","loading","currentScene","imageObject","fontSize","col","row","rows","tileMapRows","cols","tileMapCols","tileMapTileWidth","tileMapTileHeight","initTileMatrix","matrix","matrixValue","tileImageObject","getTileImageObject","tileBounds","Tile","destinationX","destinationY","ImageObject","towerImage","shootRange","rotation","southAngle","updateTarget","updateTargetInRange","updateRotation","drawRange","renderRotatedImageSource","drawSelection","setSelection","selected","renderEllipse","target","targetDirection","targetInRange","xDistance","yDistance","atan2","PI","closestEnemy","closestDistance","livingEnemies","PlainTower","BaseTower","super","plainTowerShootSpeed","plainTowerShootRate","shootElapsed","accuracyEnabled","plainTowerShootRange","updateShoot","towers","tower","canvasWidth","canvasHeight","backgroundBounds","gameCanvas","context","getContext","color","fill","originalFillStyle","fillStyle","originalStrokeStyle","strokeStyle","fillRect","beginPath","strokeRect","text","fontFamily","font","fillText","renderImageRect","w","h","drawImage","destRect","save","translate","rotate","rotatedDestRect","restore","centerX","centerY","opacity","radius","globalAlpha","ellipse","stroke","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","Game","GameConfig","RenderEngine","AssetManager","SceneManager","GameTime","start","running","loop","requestAnimationFrame","event"],"sourceRoot":""}