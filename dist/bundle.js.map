{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://towers/./src/AssetLoading/assetManager.ts","webpack://towers/./src/AssetLoading/imageAsset.ts","webpack://towers/./src/DataObjects/gameTime.ts","webpack://towers/./src/DataObjects/imageObject.ts","webpack://towers/./src/DataObjects/rectangle.ts","webpack://towers/./src/DataObjects/vector2.ts","webpack://towers/./src/Enemies/enemy.ts","webpack://towers/./src/Enemies/enemySpawner.ts","webpack://towers/./src/Levels/levelManager.ts","webpack://towers/./src/Menu/menu.ts","webpack://towers/./src/Projectiles/projectile.ts","webpack://towers/./src/Projectiles/projectileEngine.ts","webpack://towers/./src/Scenes/gameScene.ts","webpack://towers/./src/Scenes/loadScene.ts","webpack://towers/./src/Scenes/sceneManager.ts","webpack://towers/./src/Scenes/scenes.enum.ts","webpack://towers/./src/Tiles/tile.ts","webpack://towers/./src/Tiles/tileMap.ts","webpack://towers/./src/Towers/baseTower.ts","webpack://towers/./src/Towers/plainTower.ts","webpack://towers/./src/Towers/towerManager.ts","webpack://towers/./src/gameConfig.ts","webpack://towers/./src/renderEngine.ts","webpack://towers/webpack/bootstrap","webpack://towers/./src/game.ts"],"sourcesContent":["import { Level } from '../Levels/level';\r\nimport { ImageAsset } from './imageAsset';\r\n\r\nexport class AssetManager {\r\n    images: ImageAsset[] = [];\r\n\r\n    levelInfo: Level[] = [];\r\n\r\n    levelInfoLoaded: boolean;\r\n\r\n    totalAssets: number;\r\n\r\n    public loadedAssetCount: number;\r\n\r\n    public loadCompleted: boolean;\r\n\r\n    init(): void {\r\n        this.levelInfoLoaded = false;\r\n        this.loadCompleted = false;\r\n        this.totalAssets = 0;\r\n        this.initAssets();\r\n    }\r\n\r\n    initAssets(): void {\r\n        const request = new XMLHttpRequest();\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.totalAssets = data.assetCount;\r\n                this.initImages(data.imageAssets);\r\n                this.initLevelInfo(data.levelInfoFile);\r\n            }\r\n        };\r\n        request.open('get', './assets/assetManifest.json', true);\r\n        request.send();\r\n    }\r\n\r\n    initImages(imageAssets: any): void {\r\n        imageAssets.forEach(asset => {\r\n            const image = new ImageAsset(asset.key, asset.src);\r\n            this.images.push(image);\r\n        });\r\n\r\n        this.images.forEach(img => {\r\n            img.init();\r\n        });\r\n    }\r\n\r\n    initLevelInfo(levelInfoFile: string): void {\r\n        if (!levelInfoFile) {\r\n            console.error('no level info file provided');\r\n            return;\r\n        }\r\n\r\n        const request = new XMLHttpRequest();\r\n\r\n        request.onload = (): void => {\r\n            if (request.status === 200) {\r\n                const data = JSON.parse(request.responseText);\r\n                this.levelInfo = data;\r\n                this.levelInfoLoaded = true;\r\n            }\r\n        };\r\n        request.open('get', levelInfoFile, true);\r\n        request.send();\r\n    }\r\n\r\n    update(): void {\r\n        this.loadedAssetCount = this.images.filter(x => x.loaded).length;\r\n        this.loadedAssetCount = this.levelInfoLoaded\r\n            ? (this.loadedAssetCount += 1)\r\n            : this.loadedAssetCount;\r\n\r\n        if (this.totalAssets !== 0 && this.totalAssets === this.loadedAssetCount) {\r\n            this.loadCompleted = true;\r\n        }\r\n    }\r\n\r\n    getImage(key: string): HTMLImageElement {\r\n        return this.images.filter(x => x.key === key).at(0).image;\r\n    }\r\n}\r\n","export class ImageAsset {\r\n    public loaded: boolean;\r\n\r\n    public image: HTMLImageElement;\r\n\r\n    public key: string;\r\n\r\n    src: string;\r\n\r\n    constructor(key: string, src: string) {\r\n        this.loaded = false;\r\n        this.key = key;\r\n        this.src = src;\r\n    }\r\n\r\n    init(): void {\r\n        this.image = new Image();\r\n        this.image.onload = (): void => {\r\n            this.loaded = true;\r\n        };\r\n        this.image.src = this.src;\r\n    }\r\n}\r\n","export class GameTime {\r\n    public delta = 0;\r\n\r\n    private previousLoopTime: number = Date.now();\r\n\r\n    public update(): void {\r\n        const currentTime = Date.now();\r\n        const delta = currentTime - this.previousLoopTime;\r\n        this.delta = delta / 1000;\r\n        this.previousLoopTime = currentTime;\r\n    }\r\n}\r\n","import { Rectangle } from './rectangle';\r\n\r\nexport class ImageObject {\r\n    public image: HTMLImageElement;\r\n\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    public sx: number;\r\n\r\n    public sy: number;\r\n\r\n    public swidth: number;\r\n\r\n    public sheight: number;\r\n\r\n    private sourceRect: Rectangle = null;\r\n\r\n    private destinationRect: Rectangle = null;\r\n\r\n    public get sourceRectangle(): Rectangle {\r\n        if (this.sourceRect == null) {\r\n            this.sourceRect = new Rectangle(this.sx, this.sy, this.swidth, this.sheight);\r\n        }\r\n\r\n        return this.sourceRect;\r\n    }\r\n\r\n    public get destinationRectangle(): Rectangle {\r\n        if (this.destinationRect == null) {\r\n            this.destinationRect = new Rectangle(this.x, this.y, this.width, this.height);\r\n        }\r\n\r\n        return this.destinationRect;\r\n    }\r\n}\r\n","export class Rectangle {\r\n    public left: number;\r\n\r\n    public top: number;\r\n\r\n    public bottom: number;\r\n\r\n    public right: number;\r\n\r\n    public width: number;\r\n\r\n    public height: number;\r\n\r\n    constructor(left: number, top: number, width: number, height: number) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.update();\r\n    }\r\n\r\n    private updateRight(): void {\r\n        this.right = this.left + this.width;\r\n    }\r\n\r\n    private updateBottom(): void {\r\n        this.bottom = this.top + this.height;\r\n    }\r\n\r\n    public update(): void {\r\n        this.updateRight();\r\n        this.updateBottom();\r\n    }\r\n\r\n    public intersectRect(rectangle: Rectangle): boolean {\r\n        return !(\r\n            rectangle.left > this.right ||\r\n            rectangle.right < this.left ||\r\n            rectangle.top > this.bottom ||\r\n            rectangle.bottom < this.top\r\n        );\r\n    }\r\n\r\n    public containsRect(rectangle: Rectangle): boolean {\r\n        return (\r\n            this.left <= rectangle.left &&\r\n            rectangle.right <= this.right &&\r\n            this.top <= rectangle.top &&\r\n            rectangle.bottom <= this.bottom\r\n        );\r\n    }\r\n\r\n    public get getCenterWidth(): number {\r\n        this.updateRight();\r\n        return this.right - this.width / 2;\r\n    }\r\n\r\n    public get getCenterHeight(): number {\r\n        this.updateBottom();\r\n        return this.bottom - this.height / 2;\r\n    }\r\n\r\n    public clone(): Rectangle {\r\n        return new Rectangle(this.left, this.top, this.width, this.height);\r\n    }\r\n\r\n    public equals(rect: Rectangle): boolean {\r\n        return (\r\n            this.left == rect.left &&\r\n            this.top == rect.top &&\r\n            this.width == rect.width &&\r\n            this.height == rect.height\r\n        );\r\n    }\r\n\r\n    public toString(): string {\r\n        return `x:${this.left} y: ${this.top} w: ${this.width} h:${this.height}`;\r\n    }\r\n}\r\n","export class Vector2 {\r\n    public x: number;\r\n\r\n    public y: number;\r\n\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public subtract(vector2: Vector2): Vector2 {\r\n        return new Vector2(this.x - vector2.x, this.y - vector2.y);\r\n    }\r\n\r\n    public distance(vector2: Vector2): number {\r\n        const x = (this.x - vector2.x) * (this.x - vector2.x);\r\n        const y = (this.y - vector2.y) * (this.y - vector2.y);\r\n        return Math.sqrt(x + y);\r\n    }\r\n\r\n    public magnitude(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    public normalize(): Vector2 {\r\n        const distance = Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n        const normalX = this.x / distance;\r\n        const normalY = this.y / distance;\r\n\r\n        return new Vector2(isNaN(normalX) ? 0 : normalX, isNaN(normalY) ? 0 : normalY);\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Enemy {\r\n    public position: Vector2;\r\n\r\n    public size: Vector2;\r\n\r\n    public active: boolean;\r\n\r\n    public center: Vector2;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private originalWayPoints: any;\r\n\r\n    private movementWayPoints: any;\r\n\r\n    private wayPointReachedThreshold = 2;\r\n\r\n    private movements: any;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private nextMovePoint: Vector2;\r\n\r\n    private normalizedDirection: Vector2;\r\n\r\n    private distanceFromNextWaypoint: number;\r\n\r\n    private moveSpeed = 75;\r\n\r\n    private hp = 0;\r\n\r\n    private maxHp = 5;\r\n\r\n    private hpBounds: Rectangle;\r\n\r\n    private liveBounds: Rectangle;\r\n\r\n    private topPadding = 10;\r\n\r\n    private hpRemainingBarColor = 'red';\r\n\r\n    private hpFullBarColor = 'green';\r\n\r\n    private enemyName: string;\r\n\r\n    private alive = false;\r\n\r\n    constructor(enemyImage: HTMLImageElement) {\r\n        this.enemyImage = enemyImage;\r\n        this.originalWayPoints = window.tileMap.wayPoints;\r\n        this.reset(0, 0);\r\n    }\r\n\r\n    public reset(moveSpeed: number, maxHp: number): void {\r\n        this.active = false;\r\n        this.alive = false;\r\n        this.maxHp = maxHp;\r\n        this.hp = this.maxHp;\r\n        this.moveSpeed = moveSpeed;\r\n        this.movementWayPoints = this.originalWayPoints.slice();\r\n        this.movements = { left: false, right: false, up: false, down: false };\r\n        this.position = new Vector2(0, 0);\r\n        this.size = new Vector2(48, 48);\r\n        this.center = new Vector2(0, 0);\r\n        this.velocity = new Vector2(0, 0);\r\n        this.bounds = new Rectangle(0, 0, 0, 0);\r\n        this.nextMovePoint = null;\r\n        this.hpBounds = new Rectangle(\r\n            this.bounds.left,\r\n            this.bounds.top - this.topPadding,\r\n            this.bounds.width,\r\n            this.bounds.height\r\n        );\r\n        this.liveBounds = this.hpBounds.clone();\r\n        this.enemyName = Math.random().toString();\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        let onLastWaypoint = false;\r\n        if (this.movementWayPoints.length <= 0) {\r\n            onLastWaypoint = true;\r\n        }\r\n\r\n        if (!this.nextMovePoint) {\r\n            const firstWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds =\r\n                window.tileMap.tileMatrix[firstWayPoint.y][firstWayPoint.x].bounds;\r\n            this.nextMovePoint = new Vector2(\r\n                waypointBounds.getCenterWidth,\r\n                waypointBounds.getCenterHeight\r\n            );\r\n        }\r\n\r\n        this.updateBounds();\r\n        this.updateHpBounds();\r\n\r\n        this.direction = this.nextMovePoint.subtract(this.center);\r\n        this.distanceFromNextWaypoint = this.direction.magnitude();\r\n\r\n        if (this.nextWaypointReached()) {\r\n            if (onLastWaypoint) {\r\n                this.nextMovePoint = null;\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': end reached');\r\n                window.dispatchEvent(new CustomEvent('enemyReachedEnd'));\r\n                return;\r\n            }\r\n            const nextWayPoint = this.movementWayPoints.shift();\r\n            const waypointBounds = window.tileMap.tileMatrix[nextWayPoint.y][nextWayPoint.x].bounds;\r\n            this.nextMovePoint.x = waypointBounds.getCenterWidth;\r\n            this.nextMovePoint.y = waypointBounds.getCenterHeight;\r\n            this.direction = this.center.subtract(this.nextMovePoint);\r\n        }\r\n\r\n        this.normalizedDirection = this.direction.normalize();\r\n        if (\r\n            !Number.isNaN(this.normalizedDirection.x) &&\r\n            !Number.isNaN(this.normalizedDirection.y)\r\n        ) {\r\n            this.velocity.x = this.normalizedDirection.x * (this.moveSpeed * delta);\r\n            this.velocity.y = this.normalizedDirection.y * (this.moveSpeed * delta);\r\n            this.setMoveDirection();\r\n        }\r\n\r\n        this.applyVelocity();\r\n    }\r\n\r\n    private nextWaypointReached(): boolean {\r\n        return this.distanceFromNextWaypoint < this.wayPointReachedThreshold;\r\n    }\r\n\r\n    private updateBounds(): void {\r\n        this.bounds.left = this.position.x;\r\n        this.bounds.top = this.position.y;\r\n        this.bounds.width = this.size.x;\r\n        this.bounds.height = this.size.y;\r\n        this.bounds.update();\r\n\r\n        this.updateHpBounds();\r\n        this.updateLifeBounds();\r\n\r\n        this.center.x = this.bounds.getCenterWidth;\r\n        this.center.y = this.bounds.getCenterHeight;\r\n    }\r\n\r\n    private updateHpBounds(): void {\r\n        const percentageRemaining = (this.hp * 100) / this.maxHp;\r\n        const percentageDiff = 100 - percentageRemaining;\r\n\r\n        const percentageLive = (this.liveBounds.width * percentageDiff) / 100;\r\n        this.hpBounds.width = this.liveBounds.width - percentageLive;\r\n\r\n        this.hpBounds.left = this.bounds.left;\r\n        this.hpBounds.top = this.bounds.top;\r\n        this.hpBounds.height = this.bounds.height / this.topPadding;\r\n        this.hpBounds.update();\r\n    }\r\n\r\n    private updateLifeBounds(): void {\r\n        this.liveBounds.left = this.bounds.left;\r\n        this.liveBounds.top = this.bounds.top;\r\n        this.liveBounds.width = this.bounds.width;\r\n        this.liveBounds.height = this.bounds.height / this.topPadding;\r\n        this.liveBounds.update();\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 68, 80);\r\n\r\n        window.renderEngine.renderImageSource(this.enemyImage, sourceRectangle, this.bounds);\r\n\r\n        // TODO:\r\n        // Introduce damage percentage bar\r\n        this.drawRemainingHPBar();\r\n        this.drawFullHPBar();\r\n    }\r\n\r\n    private drawRemainingHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.liveBounds, this.hpRemainingBarColor, true);\r\n    }\r\n\r\n    private drawFullHPBar(): void {\r\n        // debugger;\r\n        window.renderEngine.renderRect(this.hpBounds, this.hpFullBarColor, true);\r\n    }\r\n\r\n    private setMoveDirection(): void {\r\n        this.movements.left = this.velocity.x < 0;\r\n        this.movements.right = this.velocity.x > 0;\r\n\r\n        this.movements.up = this.velocity.y < 0;\r\n        this.movements.down = this.velocity.y > 0;\r\n\r\n        if (\r\n            (this.movements.left || this.movements.right) &&\r\n            (this.movements.up || this.movements.down)\r\n        ) {\r\n            // We detect if both horizontal and vertical movement is set.\r\n            // As we can only play one animation per axis movement we should determine\r\n            // what axis has the greater velocity value and use that as the direction.\r\n\r\n            const horizontalValue = this.velocity.x < 0 ? this.velocity.x * -1 : this.velocity.x;\r\n\r\n            const verticalValue = this.velocity.y < 0 ? this.velocity.y * -1 : this.velocity.y;\r\n\r\n            if (horizontalValue > verticalValue) {\r\n                this.movements.left = this.velocity.x < 0;\r\n                this.movements.right = this.velocity.x > 0;\r\n                this.movements.up = false;\r\n                this.movements.down = false;\r\n            } else {\r\n                this.movements.up = this.velocity.y < 0;\r\n                this.movements.down = this.velocity.y > 0;\r\n                this.movements.left = false;\r\n                this.movements.right = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyVelocity(): void {\r\n        this.position.x += this.velocity.x;\r\n        this.position.y += this.velocity.y;\r\n    }\r\n\r\n    public hit(): void {\r\n        if (this.active) {\r\n            this.hp -= 1;\r\n            // console.log(this.enemyName + ': hit ' + this.hp);\r\n\r\n            if (this.hp <= 0) {\r\n                this.active = false;\r\n                // console.log(this.enemyName + ': killed');\r\n                window.dispatchEvent(new CustomEvent('enemyKilled'));\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Enemy } from './enemy';\r\n\r\nexport class EnemySpawner {\r\n    public enemies: Enemy[] = [];\r\n\r\n    private enemyImage: HTMLImageElement;\r\n\r\n    private enemySpawnCount = 0;\r\n\r\n    private enemySpawnCountMax: number;\r\n\r\n    private enemySpawnRate: number;\r\n\r\n    private enemySpawnElapsed = 0;\r\n\r\n    private enemiesKilled = 0;\r\n\r\n    private enemiesEscaped = 0;\r\n\r\n    constructor() {\r\n        this.enemyImage = window.assetManager.getImage('squid');\r\n        this.setCurrentLevel();\r\n\r\n        window.addEventListener('enemyKilled', () => {\r\n            this.enemiesKilled += 1;\r\n        });\r\n        window.addEventListener('enemyReachedEnd', () => {\r\n            this.enemiesEscaped += 1;\r\n        });\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.update(delta);\r\n        });\r\n\r\n        this.updateSpawner(delta);\r\n        this.updateRoundCheck();\r\n    }\r\n\r\n    private updateSpawner(delta: number): void {\r\n        if (this.enemySpawnCount >= this.enemySpawnCountMax) {\r\n            return;\r\n        }\r\n        this.enemySpawnElapsed += delta;\r\n        if (this.enemySpawnElapsed >= this.enemySpawnRate) {\r\n            this.enemySpawnElapsed = 0;\r\n            this.createEnemy();\r\n            this.enemySpawnCount += 1;\r\n        }\r\n    }\r\n\r\n    private updateRoundCheck(): void {\r\n        if (\r\n            this.enemiesEscaped + this.enemiesKilled ===\r\n            window.levelManager.currentLevel.enemySpawnCountMax\r\n        ) {\r\n            this.enemiesKilled = 0;\r\n            this.enemiesEscaped = 0;\r\n            this.enemySpawnCount = 0;\r\n            window.levelManager.nextLevel();\r\n            this.setCurrentLevel();\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        this.enemies.forEach(enemy => {\r\n            enemy.draw();\r\n        });\r\n    }\r\n\r\n    public createEnemy(): void {\r\n        // TODO:\r\n        // Reset inactive enemies from pool instead of creating new ones\r\n        // THIS IS A LEAK BTW\r\n        // console.clear();\r\n        // console.log(\"enemy in array count: \" + this.enemies.length);\r\n\r\n        const enemy = new Enemy(this.enemyImage);\r\n        enemy.reset(\r\n            window.levelManager.currentLevel.enemyMoveSpeed,\r\n            window.levelManager.currentLevel.enemyMaxHp\r\n        );\r\n        enemy.active = true;\r\n        this.enemies.push(enemy);\r\n    }\r\n\r\n    private setCurrentLevel(): void {\r\n        this.enemySpawnCountMax = window.levelManager.currentLevel.enemySpawnCountMax;\r\n        this.enemySpawnRate = window.levelManager.currentLevel.enemySpawnRate;\r\n    }\r\n}\r\n","import { Level } from './level';\r\n\r\nexport class LevelManager {\r\n    private levelInfo: Level[];\r\n\r\n    public currentLevel: Level;\r\n\r\n    constructor(levelInfo: Level[]) {\r\n        this.levelInfo = levelInfo;\r\n        this.loadLevel();\r\n    }\r\n\r\n    private loadLevel(): void {\r\n        if (this.currentLevel == null) {\r\n            this.currentLevel = this.levelInfo.at(0);\r\n        }\r\n    }\r\n\r\n    public nextLevel(): void {\r\n        const index = this.currentLevel.levelIndex + 1;\r\n        for (let l = 0; l < this.levelInfo.length; l += 1) {\r\n            if (this.levelInfo[l].levelIndex === index) {\r\n                this.currentLevel = this.levelInfo[l];\r\n                return;\r\n            }\r\n        }\r\n\r\n        // NOTE: If we get here, no more level exist\r\n        // TODO:\r\n        // Raise end of level notification\r\n        // console.log(\"last level done\")\r\n    }\r\n}\r\n","import { ImageKeyPair } from '../Types/imageKeyPair';\r\n\r\nexport class Menu {\r\n    public stagedTowerImageWidth = 48;\r\n\r\n    public stagedTowerImageHeight = 48;\r\n\r\n    private imageDictionary: ImageKeyPair[];\r\n\r\n    private stagedTower: string;\r\n\r\n    private menuHeight: number;\r\n\r\n    constructor() {\r\n        window.addEventListener('plainTowerClicked', () => {\r\n            this.towerClicked('plain');\r\n        });\r\n        window.addEventListener('slowTowerClicked', () => {\r\n            this.towerClicked('slow');\r\n        });\r\n        this.menuHeight = document.getElementById('tower_menu').clientHeight;\r\n\r\n        this.imageDictionary = [\r\n            { key: 'plain', image: window.assetManager.getImage('towerplain') },\r\n            { key: 'slow', image: window.assetManager.getImage('towerslow') }\r\n        ];\r\n    }\r\n\r\n    public clearStagedTower(): void {\r\n        this.stagedTower = '';\r\n    }\r\n\r\n    private towerClicked(type: string): void {\r\n        this.stagedTower = type;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!window.mouseInfo || !this.stagedTower) {\r\n            return;\r\n        }\r\n\r\n        const tX = window.mouseInfo.x - this.stagedTowerImageWidth / 2;\r\n        const tY = window.mouseInfo.y - this.stagedTowerImageHeight / 2 - this.menuHeight;\r\n\r\n        const { image } = this.imageDictionary.find(x => x.key === this.stagedTower);\r\n        window.renderEngine.renderImage(\r\n            image,\r\n            tX,\r\n            tY,\r\n            this.stagedTowerImageWidth,\r\n            this.stagedTowerImageHeight\r\n        );\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\n\r\nexport class Projectile {\r\n    public active = false;\r\n\r\n    private startPosition: Vector2;\r\n\r\n    private direction: Vector2;\r\n\r\n    private worldBounds: Rectangle;\r\n\r\n    private inWorldBounds: boolean;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private moveSpeed = 0.5;\r\n\r\n    private velocity: Vector2;\r\n\r\n    private ttl = 0;\r\n\r\n    private ttlMax = 2;\r\n\r\n    private projectileColor: string;\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    private imageSourceRect: Rectangle;\r\n\r\n    constructor(projectileImage: HTMLImageElement) {\r\n        this.projectileImage = projectileImage;\r\n        this.worldBounds = window.tileMap.bounds;\r\n\r\n        this.bounds = new Rectangle(0, 0, 24, 24);\r\n        this.velocity = new Vector2(0, 0);\r\n        this.projectileColor = 'black';\r\n        this.imageSourceRect = new Rectangle(0, 0, 32, 32);\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.bounds.update();\r\n        this.updateTTL(delta);\r\n        this.updateVelocity(delta);\r\n    }\r\n\r\n    private updateTTL(delta: number): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n        this.ttl -= delta;\r\n        if (this.ttl <= 0) {\r\n            this.active = false;\r\n        }\r\n    }\r\n\r\n    private updateVelocity(delta: number): void {\r\n        if (!this.direction || !this.active) {\r\n            return;\r\n        }\r\n        this.velocity.x = this.direction.x * (this.moveSpeed * delta);\r\n        this.velocity.y = this.direction.y * (this.moveSpeed * delta);\r\n\r\n        this.bounds.left += this.velocity.x;\r\n        this.bounds.top += this.velocity.y;\r\n    }\r\n\r\n    public draw(): void {\r\n        if (!this.active) {\r\n            return;\r\n        }\r\n\r\n        window.renderEngine.renderImageSource(\r\n            this.projectileImage,\r\n            this.imageSourceRect,\r\n            this.bounds\r\n        );\r\n    }\r\n\r\n    public reset(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        this.active = true;\r\n        this.ttl = this.ttlMax;\r\n        this.startPosition = startPosition;\r\n        this.direction = direction;\r\n        this.moveSpeed = moveSpeed;\r\n\r\n        this.velocity.x = 0;\r\n        this.velocity.y = 0;\r\n\r\n        this.bounds.left = this.startPosition.x - this.bounds.width / 2;\r\n        this.bounds.top = this.startPosition.y - this.bounds.height / 2;\r\n        this.bounds.update();\r\n    }\r\n}\r\n","import { Vector2 } from '../DataObjects/vector2';\r\nimport { Projectile } from './projectile';\r\n\r\nexport class ProjectileEngine {\r\n    public projectiles: Projectile[] = [];\r\n\r\n    private projectileImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.projectileImage = window.assetManager.getImage('projectile');\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.update(delta);\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.projectiles.forEach(projectile => {\r\n            projectile.draw();\r\n        });\r\n    }\r\n\r\n    public activateProjectile(startPosition: Vector2, direction: Vector2, moveSpeed: number): void {\r\n        let poolSufficient = false;\r\n        for (let i = 0; i < this.projectiles.length; i += 1) {\r\n            if (!this.projectiles[i].active) {\r\n                this.projectiles[i].reset(startPosition, direction, moveSpeed);\r\n                poolSufficient = true;\r\n                // console.log('projectile reset');\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!poolSufficient) {\r\n            this.expandProjectilePool(startPosition, direction, moveSpeed);\r\n        }\r\n    }\r\n\r\n    private expandProjectilePool(\r\n        startPosition: Vector2,\r\n        direction: Vector2,\r\n        moveSpeed: number\r\n    ): Projectile {\r\n        const projectile = new Projectile(this.projectileImage);\r\n        this.projectiles.push(projectile);\r\n        // console.log('grow pool size: ' + this.projectiles.length);\r\n        this.activateProjectile(startPosition, direction, moveSpeed);\r\n        return projectile;\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { EnemySpawner } from '../Enemies/enemySpawner';\r\nimport { LevelManager } from '../Levels/levelManager';\r\nimport { Menu } from '../Menu/menu';\r\nimport { ProjectileEngine } from '../Projectiles/projectileEngine';\r\nimport { TileMap } from '../Tiles/tileMap';\r\nimport { TowerManager } from '../Towers/towerManager';\r\nimport { SceneInterface } from './scene.interface';\r\n\r\nexport class GameScene implements SceneInterface {\r\n    backgroundImage: HTMLImageElement;\r\n\r\n    tileImage: HTMLImageElement;\r\n\r\n    towerManager: TowerManager;\r\n\r\n    projectileEngine: ProjectileEngine;\r\n\r\n    menu: Menu;\r\n\r\n    // TODO: Abstract into a manager\r\n    collisionCheckElapsed = 0;\r\n\r\n    init(): void {\r\n        this.backgroundImage = window.assetManager.getImage('background');\r\n        this.tileImage = window.assetManager.getImage('tiles');\r\n        window.levelManager = new LevelManager(window.assetManager.levelInfo);\r\n        this.menu = new Menu();\r\n\r\n        window.tileMap = new TileMap(this.tileImage);\r\n        window.enemySpawner = new EnemySpawner();\r\n        this.towerManager = new TowerManager();\r\n        window.projectileEngine = new ProjectileEngine();\r\n\r\n        // TODO: Remove, towers to be added with user input\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[3][3]);\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[5][5]);\r\n        this.towerManager.createTower(window.tileMap.tileMatrix[8][7]);\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            this.mouseMove(e.x, e.y);\r\n        });\r\n        window.addEventListener('mousedown', () => {\r\n            this.mouseDown();\r\n        });\r\n        window.addEventListener('mouseup', () => {\r\n            this.mouseUp();\r\n        });\r\n    }\r\n\r\n    update(): void {\r\n        const { delta } = window.gameTime;\r\n        this.checkProjectileEnemyCollision(delta);\r\n\r\n        this.towerManager.update();\r\n        window.enemySpawner.update(delta);\r\n        window.projectileEngine.update(delta);\r\n    }\r\n\r\n    // TODO: Abstract into a manager\r\n    private checkProjectileEnemyCollision(delta: number): void {\r\n        // TODO: Reduce the rate at which collision check is done\r\n        //       This saves browser performance but is less accurate,\r\n        //       missing some collisions.\r\n        this.collisionCheckElapsed += delta;\r\n        if (this.collisionCheckElapsed <= 0.001) {\r\n            return;\r\n        }\r\n        this.collisionCheckElapsed = 0;\r\n        window.enemySpawner.enemies.forEach(enemy => {\r\n            window.projectileEngine.projectiles.forEach(projectile => {\r\n                if (\r\n                    projectile.active &&\r\n                    enemy.active &&\r\n                    enemy.bounds.containsRect(projectile.bounds)\r\n                ) {\r\n                    enemy.hit();\r\n                    projectile.active = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.clearRect(window.tileMap.bounds);\r\n        window.tileMap.draw();\r\n\r\n        // TODO:\r\n        // Create abstraction into animated text rendering.\r\n        window.renderEngine.renderText(\r\n            window.levelManager.currentLevel.levelName,\r\n            64,\r\n            32,\r\n            'red',\r\n            32,\r\n            'impact'\r\n        );\r\n\r\n        window.enemySpawner.draw();\r\n        this.towerManager.draw();\r\n        window.projectileEngine.draw();\r\n        this.menu.draw();\r\n    }\r\n\r\n    static isOverMouseMenu(): boolean {\r\n        const menuBounds = GameScene.getElementBounds('tower_menu');\r\n        return menuBounds.containsRect(new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1));\r\n    }\r\n\r\n    static isOverGameBounds(): boolean {\r\n        return window.tileMap.bounds.containsRect(\r\n            new Rectangle(window.mouseInfo.x, window.mouseInfo.y, 1, 1)\r\n        );\r\n    }\r\n\r\n    static getElementBounds(elementId: string): Rectangle {\r\n        const element = document.getElementById(elementId);\r\n        return new Rectangle(\r\n            element.clientLeft,\r\n            element.clientTop,\r\n            element.clientWidth,\r\n            element.clientHeight\r\n        );\r\n    }\r\n\r\n    mouseDown(): void {}\r\n\r\n    mouseUp(): void {\r\n        if (GameScene.isOverMouseMenu()) {\r\n            return;\r\n        }\r\n        if (!GameScene.isOverGameBounds()) {\r\n            return;\r\n        }\r\n\r\n        const x = Math.floor(window.mouseInfo.x / window.tileMap.tileWidth);\r\n        const y = Math.floor(\r\n            (window.mouseInfo.y - window.tileMap.tileHeight) / window.tileMap.tileHeight\r\n        );\r\n        const destinationTile = window.tileMap.tileMatrix[y][x];\r\n        this.menu.clearStagedTower();\r\n        this.towerManager.createTower(destinationTile);\r\n\r\n        console.log(\r\n            `tileX:${x} tileY:${y} destTile:${destinationTile.bounds} mouseX:${window.mouseInfo.x} mouseY:${window.mouseInfo.y}`\r\n        );\r\n    }\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class LoadScene implements SceneInterface {\r\n    private loadScreenRect: Rectangle;\r\n\r\n    private loadingText: string;\r\n\r\n    constructor() {\r\n        this.loadScreenRect = new Rectangle(0, 0, 800, 480);\r\n    }\r\n\r\n    init(): void {}\r\n\r\n    update(): void {\r\n        this.loadingText = `${window.assetManager.loadedAssetCount}/${window.assetManager.totalAssets}`;\r\n        window.assetManager.update();\r\n        if (window.assetManager.loadCompleted) {\r\n            window.sceneManager.toggleActiveScene(Scenes.game);\r\n        }\r\n    }\r\n\r\n    render(): void {\r\n        window.renderEngine.renderText(this.loadingText, 0, 0, 'blue', 30, 'impact');\r\n        window.renderEngine.renderRect(this.loadScreenRect, 'black', true);\r\n    }\r\n\r\n    mouseDown(): void {}\r\n\r\n    mouseUp(): void {}\r\n\r\n    mouseMove(x: number, y: number): void {}\r\n\r\n    resize(): void {}\r\n}\r\n","import { GameScene } from './gameScene';\r\nimport { LoadScene } from './loadScene';\r\nimport { SceneInterface } from './scene.interface';\r\nimport { Scenes } from './scenes.enum';\r\n\r\nexport class SceneManager {\r\n    private currentScene: SceneInterface;\r\n\r\n    private loadScene: LoadScene;\r\n\r\n    private gameScene: GameScene;\r\n\r\n    constructor() {\r\n        // TODO:\r\n        // Inject depependencies, no initialization\r\n        this.loadScene = new LoadScene();\r\n        this.gameScene = new GameScene();\r\n    }\r\n\r\n    public toggleActiveScene(newScene: Scenes): void {\r\n        if (newScene === Scenes.loading) {\r\n            this.currentScene = this.loadScene;\r\n        }\r\n\r\n        if (newScene === Scenes.game) {\r\n            this.currentScene = this.gameScene;\r\n        }\r\n\r\n        this.currentScene.init();\r\n    }\r\n\r\n    public update(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.update();\r\n        }\r\n    }\r\n\r\n    public render(): void {\r\n        if (this.currentScene) {\r\n            this.currentScene.render();\r\n        }\r\n    }\r\n}\r\n","export enum Scenes {\r\n    loading,\r\n    game\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\n\r\nexport class Tile {\r\n    public bounds: Rectangle;\r\n\r\n    private imageObject: ImageObject;\r\n\r\n    private fontSize = 12;\r\n\r\n    constructor(bounds: Rectangle, imageObject: ImageObject) {\r\n        this.bounds = bounds;\r\n        this.imageObject = imageObject;\r\n    }\r\n\r\n    public draw(col: number, row: number): void {\r\n        window.renderEngine.renderImageSource(\r\n            this.imageObject.image,\r\n            this.imageObject.sourceRectangle,\r\n            this.imageObject.destinationRectangle\r\n        );\r\n\r\n        // this.gameScene.renderEngine.renderText(\r\n        //     col + '_' + row,\r\n        //     this.bounds.left,\r\n        //     this.bounds.top + this.fontSize,\r\n        //     'black',\r\n        //     this.fontSize,\r\n        //     'Calibri');\r\n    }\r\n}\r\n","import { ImageObject } from '../DataObjects/imageObject';\r\nimport { Rectangle } from '../DataObjects/rectangle';\r\nimport { Tile } from './tile';\r\n\r\nexport class TileMap {\r\n    public wayPoints: any = [];\r\n\r\n    public tileMatrix: Tile[][];\r\n\r\n    public rows = window.gameConfig.tileMapRows;\r\n\r\n    public cols = window.gameConfig.tileMapCols;\r\n\r\n    public tileWidth = window.gameConfig.tileMapTileWidth;\r\n\r\n    public tileHeight = window.gameConfig.tileMapTileHeight;\r\n\r\n    public bounds: Rectangle;\r\n\r\n    private tileImage: HTMLImageElement;\r\n\r\n    private waterTileImageObject: ImageObject;\r\n\r\n    private pathTileImageObject: ImageObject;\r\n\r\n    constructor(tileImage: HTMLImageElement) {\r\n        this.tileImage = tileImage;\r\n\r\n        this.initTileMatrix();\r\n        this.bounds = new Rectangle(0, 0, this.cols * this.tileWidth, this.rows * this.tileHeight);\r\n    }\r\n\r\n    private initTileMatrix(): void {\r\n        // TODO:\r\n        // Read matrix data from configurable file\r\n        const matrix = [\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n            [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 1, 1, 1, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\r\n            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\r\n        ];\r\n\r\n        this.wayPoints = [\r\n            { x: 0, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: 0, y: 2 },\r\n            { x: 1, y: 2 },\r\n            { x: 2, y: 2 },\r\n            { x: 2, y: 3 },\r\n            { x: 2, y: 4 },\r\n            { x: 3, y: 4 },\r\n            { x: 4, y: 4 },\r\n            { x: 4, y: 3 },\r\n            { x: 4, y: 2 },\r\n            { x: 5, y: 2 },\r\n            { x: 6, y: 2 },\r\n            { x: 6, y: 3 },\r\n            { x: 6, y: 4 },\r\n            { x: 6, y: 5 },\r\n            { x: 6, y: 6 },\r\n            { x: 5, y: 6 },\r\n            { x: 4, y: 6 },\r\n            { x: 4, y: 7 },\r\n            { x: 4, y: 8 },\r\n            { x: 5, y: 8 },\r\n            { x: 5, y: 9 },\r\n            { x: 6, y: 9 },\r\n            { x: 7, y: 9 },\r\n            { x: 8, y: 9 },\r\n            { x: 9, y: 9 }\r\n        ];\r\n\r\n        this.tileMatrix = [];\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            this.tileMatrix[row] = [];\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                const matrixValue = matrix[row][col];\r\n                const tileImageObject = this.getTileImageObject(\r\n                    matrixValue,\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row\r\n                );\r\n\r\n                // TODO:\r\n                // Tile should provide underlying imageObject with coordinates and size values.\r\n                // Abstract source rectangle values into \"tilesSpriteSheet\" configuration.\r\n                const tileBounds = new Rectangle(\r\n                    this.tileWidth * col,\r\n                    this.tileHeight * row,\r\n                    this.tileWidth,\r\n                    this.tileHeight\r\n                );\r\n                // console.log('col:' + col + ' row:' + row)\r\n                this.tileMatrix[row][col] = new Tile(tileBounds, tileImageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getTileImageObject(\r\n        matrixValue: number,\r\n        destinationX: number,\r\n        destinationY: number\r\n    ): ImageObject {\r\n        const tileImageObject = new ImageObject();\r\n        tileImageObject.image = this.tileImage;\r\n        tileImageObject.x = destinationX;\r\n        tileImageObject.y = destinationY;\r\n        tileImageObject.width = this.tileWidth;\r\n        tileImageObject.height = this.tileHeight;\r\n        tileImageObject.swidth = 32;\r\n        tileImageObject.sheight = 32;\r\n\r\n        if (matrixValue === 0) {\r\n            tileImageObject.sx = 0;\r\n            tileImageObject.sy = 0;\r\n        } else {\r\n            tileImageObject.sx = 32;\r\n            tileImageObject.sy = 0;\r\n        }\r\n\r\n        return tileImageObject;\r\n    }\r\n\r\n    public draw(): void {\r\n        for (let row = 0; row < this.rows; row += 1) {\r\n            for (let col = 0; col < this.cols; col += 1) {\r\n                this.tileMatrix[row][col].draw(col, row);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Rectangle } from '../DataObjects/rectangle';\r\nimport { Vector2 } from '../DataObjects/vector2';\r\nimport { Enemy } from '../Enemies/enemy';\r\nimport { Tile } from '../Tiles/tile';\r\n\r\nexport abstract class BaseTower {\r\n    public shootRange = 20000;\r\n\r\n    public targetInRange: boolean;\r\n\r\n    public targetDirection: Vector2;\r\n\r\n    public destinationTile: Tile;\r\n\r\n    public target: Enemy;\r\n\r\n    public center: Vector2;\r\n\r\n    private rotation: number;\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    private selected: boolean;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        this.destinationTile = destinationTile;\r\n        this.towerImage = towerImage;\r\n\r\n        this.center = new Vector2(0, 0);\r\n    }\r\n\r\n    public update(): void {\r\n        this.center.x = this.destinationTile.bounds.getCenterWidth;\r\n        this.center.y = this.destinationTile.bounds.getCenterHeight;\r\n        this.destinationTile.bounds.update();\r\n\r\n        this.updateTarget();\r\n        this.updateTargetInRange();\r\n        this.updateRotation();\r\n\r\n        // console.log('targetInRange: ' + this.targetInRange);\r\n    }\r\n\r\n    public draw(): void {\r\n        this.drawRange();\r\n\r\n        // TODO:\r\n        // Implement animation class and call draw\r\n        // Animation class to handle source rect updates.\r\n        const sourceRectangle = new Rectangle(0, 0, 32, 32);\r\n\r\n        window.renderEngine.renderRotatedImageSource(\r\n            this.towerImage,\r\n            sourceRectangle,\r\n            this.destinationTile.bounds,\r\n            this.rotation\r\n        );\r\n\r\n        this.drawSelection();\r\n    }\r\n\r\n    public setSelection(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    private drawRange(): void {\r\n        window.renderEngine.renderEllipse(\r\n            this.center.x,\r\n            this.center.y,\r\n            'red',\r\n            0.5,\r\n            this.shootRange,\r\n            false\r\n        );\r\n    }\r\n\r\n    private drawSelection(): void {\r\n        // TODO:\r\n        // Draw any overlay selection effects\r\n    }\r\n\r\n    private updateTargetInRange(): void {\r\n        if (this.target != null && this.target.active) {\r\n            this.targetDirection = this.center.subtract(this.target.center);\r\n            // console.log('target direction  y: ' + this.targetDirection.x + ' y: ' + this.targetDirection.y);\r\n            const distance = this.targetDirection.magnitude();\r\n            if (distance <= this.shootRange) {\r\n                // console.log('ranged');\r\n                this.targetInRange = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.targetInRange = false;\r\n    }\r\n\r\n    private updateRotation(): void {\r\n        // Rotate the tower towards it's current target or\r\n        // rotate to default position if no target exist or if target not in range.\r\n        if (this.targetInRange) {\r\n            const xDistance = this.target.center.x - this.center.x;\r\n            const yDistance = this.target.center.y - this.center.y;\r\n            this.rotation = Math.atan2(yDistance, xDistance) * (180 / Math.PI) - 270;\r\n        }\r\n        // else {\r\n        //     if (this.rotation > 0) {\r\n        //         this.rotation = this.rotation - 0.01;\r\n        //     } else {\r\n        //         this.rotation = -90;\r\n        //     }\r\n        // }\r\n        // this.rotation = this.rotation - 270;\r\n    }\r\n\r\n    private updateTarget(): void {\r\n        let distance = 0;\r\n        let closestDistance = 99999;\r\n        let closestEnemy: Enemy;\r\n\r\n        for (let e = 0; e < window.enemySpawner.enemies.length; e += 1) {\r\n            const enemy = window.enemySpawner.enemies[e];\r\n            distance = enemy.center.distance(this.center);\r\n\r\n            if (distance < closestDistance || closestEnemy == null) {\r\n                closestDistance = distance;\r\n                closestEnemy = enemy;\r\n            }\r\n        }\r\n\r\n        this.target = closestEnemy;\r\n    }\r\n}\r\n","import { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\n\r\nexport class PlainTower extends BaseTower {\r\n    private plainTowerShootSpeed = 250;\r\n\r\n    private plainTowerShootRate = 0.7;\r\n\r\n    private shootElapsed = 0;\r\n\r\n    constructor(destinationTile: Tile, towerImage: HTMLImageElement) {\r\n        super(destinationTile, towerImage);\r\n        super.shootRange = 128;\r\n    }\r\n\r\n    public update(): void {\r\n        super.update();\r\n\r\n        this.updateShoot();\r\n    }\r\n\r\n    private updateShoot(): void {\r\n        const { delta } = window.gameTime;\r\n        this.shootElapsed += delta;\r\n        if (this.targetInRange && this.shootElapsed >= this.plainTowerShootRate) {\r\n            this.shootElapsed = 0;\r\n\r\n            // console.log('shoot');\r\n\r\n            const direction = this.target.center.subtract(this.center);\r\n            const normalizedDirection = direction.normalize();\r\n\r\n            window.projectileEngine.activateProjectile(\r\n                this.center,\r\n                normalizedDirection,\r\n                this.plainTowerShootSpeed\r\n            );\r\n        }\r\n    }\r\n\r\n    public draw(): void {\r\n        super.draw();\r\n    }\r\n}\r\n","import { Tile } from '../Tiles/tile';\r\nimport { BaseTower } from './baseTower';\r\nimport { PlainTower } from './plainTower';\r\n\r\nexport class TowerManager {\r\n    public towers: BaseTower[] = [];\r\n\r\n    private towerImage: HTMLImageElement;\r\n\r\n    constructor() {\r\n        this.towerImage = window.assetManager.getImage('towerplain');\r\n    }\r\n\r\n    public update(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.update();\r\n        });\r\n    }\r\n\r\n    public draw(): void {\r\n        this.towers.forEach(tower => {\r\n            tower.draw();\r\n        });\r\n    }\r\n\r\n    public createTower(destinationTile: Tile): void {\r\n        this.towers.push(new PlainTower(destinationTile, this.towerImage));\r\n    }\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\n\r\nexport class GameConfig {\r\n    public canvasWidth = 960;\r\n\r\n    public canvasHeight = 960;\r\n\r\n    public backgroundBounds = new Rectangle(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    public tileMapRows = 10;\r\n\r\n    public tileMapCols = 10;\r\n\r\n    public tileMapTileWidth = 96;\r\n\r\n    public tileMapTileHeight = 96;\r\n}\r\n","import { Rectangle } from './DataObjects/rectangle';\r\n\r\nexport class RenderEngine {\r\n    private context: CanvasRenderingContext2D;\r\n\r\n    constructor() {\r\n        const gameCanvas = document.getElementById('game-canvas') as HTMLCanvasElement;\r\n        this.context = gameCanvas.getContext('2d');\r\n    }\r\n\r\n    public clearRect(rect: Rectangle): void {\r\n        if (rect) {\r\n            this.context.clearRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n    }\r\n\r\n    public renderRect(rect: Rectangle, color: string, fill: boolean): void {\r\n        const originalFillStyle = this.context.fillStyle;\r\n        const originalStrokeStyle = this.context.strokeStyle;\r\n\r\n        if (fill) {\r\n            this.context.fillStyle = color;\r\n            this.context.fillRect(rect.left, rect.top, rect.width, rect.height);\r\n        } else {\r\n            this.context.beginPath();\r\n            this.context.strokeStyle = color;\r\n            this.context.strokeRect(rect.left, rect.top, rect.width, rect.height);\r\n        }\r\n\r\n        this.context.fillStyle = originalFillStyle;\r\n        this.context.strokeStyle = originalStrokeStyle;\r\n    }\r\n\r\n    public renderText(\r\n        text: string,\r\n        x: number,\r\n        y: number,\r\n        color: string,\r\n        fontSize: number,\r\n        fontFamily: string\r\n    ): void {\r\n        this.context.fillStyle = color;\r\n        this.context.font = `${fontSize}px ${fontFamily}`;\r\n        this.context.fillText(text, x, y);\r\n    }\r\n\r\n    public renderImageRect(image: HTMLImageElement, bounds: Rectangle): void {\r\n        this.renderImage(image, bounds.left, bounds.top, bounds.width, bounds.height);\r\n    }\r\n\r\n    public renderImage(\r\n        image: HTMLImageElement,\r\n        x: number,\r\n        y: number,\r\n        width: number = null,\r\n        height: number = null\r\n    ): void {\r\n        const w = width == null ? image.width : width;\r\n        const h = height == null ? image.height : height;\r\n        this.context.drawImage(image, x, y, w, h);\r\n    }\r\n\r\n    public renderImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle\r\n    ): void {\r\n        if (\r\n            sourceRect.left < 0 ||\r\n            sourceRect.top < 0 ||\r\n            sourceRect.height <= 0 ||\r\n            sourceRect.height <= 0\r\n        ) {\r\n            return;\r\n        }\r\n        this.context.drawImage(\r\n            image,\r\n            sourceRect.left,\r\n            sourceRect.top,\r\n            sourceRect.width,\r\n            sourceRect.height,\r\n            destRect.left,\r\n            destRect.top,\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n    }\r\n\r\n    public renderRotatedImageSource(\r\n        image: HTMLImageElement,\r\n        sourceRect: Rectangle,\r\n        destRect: Rectangle,\r\n        rotation = 0\r\n    ): void {\r\n        this.context.save();\r\n        this.context.translate(destRect.getCenterWidth, destRect.getCenterHeight);\r\n        this.context.rotate((rotation - 90) * (Math.PI / 180));\r\n\r\n        const rotatedDestRect = new Rectangle(\r\n            -(destRect.width / 2),\r\n            -(destRect.height / 2),\r\n            destRect.width,\r\n            destRect.height\r\n        );\r\n\r\n        this.renderImageSource(image, sourceRect, rotatedDestRect);\r\n\r\n        this.context.restore();\r\n    }\r\n\r\n    public renderEllipse(\r\n        centerX: number,\r\n        centerY: number,\r\n        color: string,\r\n        opacity: number,\r\n        radius: number,\r\n        fill: boolean\r\n    ): void {\r\n        this.context.save();\r\n        this.context.globalAlpha = opacity;\r\n        this.context.strokeStyle = color;\r\n        this.context.beginPath();\r\n        this.context.ellipse(centerX, centerY, radius, radius, Math.PI / 4, 0, 2 * Math.PI);\r\n\r\n        if (fill) {\r\n            this.context.fill();\r\n        } else {\r\n            this.context.stroke();\r\n        }\r\n        this.context.restore();\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AssetManager } from './AssetLoading/assetManager';\r\nimport { GameTime } from './DataObjects/gameTime';\r\nimport { GameConfig } from './gameConfig';\r\nimport { RenderEngine } from './renderEngine';\r\nimport { SceneInterface } from './Scenes/scene.interface';\r\nimport { SceneManager } from './Scenes/sceneManager';\r\nimport { Scenes } from './Scenes/scenes.enum';\r\n\r\nexport class Game {\r\n    public assetManager: AssetManager;\r\n\r\n    public currentScene: SceneInterface;\r\n\r\n    private running: boolean;\r\n\r\n    constructor() {\r\n        const canvas = document.getElementById('game-canvas');\r\n        //canvas.setAttribute(\"width\", window.gameConfig.canvasWidth.toString());\r\n\r\n        window.gameConfig = new GameConfig();\r\n        window.renderEngine = new RenderEngine();\r\n        window.assetManager = new AssetManager();\r\n        window.assetManager.init();\r\n        window.sceneManager = new SceneManager();\r\n        window.sceneManager.toggleActiveScene(Scenes.loading);\r\n        window.gameTime = new GameTime();\r\n\r\n        window.addEventListener('mousemove', e => {\r\n            Game.mouseMove(e);\r\n        });\r\n    }\r\n\r\n    public start(): void {\r\n        if (this.running) {\r\n            return;\r\n        }\r\n\r\n        this.running = true;\r\n        this.loop();\r\n    }\r\n\r\n    private loop(): void {\r\n        window.gameTime.update();\r\n\r\n        if (window.sceneManager) {\r\n            window.sceneManager.update();\r\n            window.sceneManager.render();\r\n        }\r\n\r\n        requestAnimationFrame(() => this.loop());\r\n    }\r\n\r\n    static mouseMove(event: any): void {\r\n        window.mouseInfo = { x: event.x, y: event.y };\r\n    }\r\n}\r\n\r\nwindow.addEventListener('load', () => {\r\n    const game = new Game();\r\n    game.start();\r\n});\r\n"],"names":["images","levelInfo","init","this","levelInfoLoaded","loadCompleted","totalAssets","initAssets","request","XMLHttpRequest","onload","status","data","JSON","parse","responseText","assetCount","initImages","imageAssets","initLevelInfo","levelInfoFile","open","send","forEach","asset","image","ImageAsset","key","src","push","img","console","error","update","loadedAssetCount","filter","x","loaded","length","getImage","at","constructor","Image","delta","previousLoopTime","Date","now","currentTime","sourceRect","destinationRect","sourceRectangle","Rectangle","sx","sy","swidth","sheight","destinationRectangle","y","width","height","left","top","updateRight","right","updateBottom","bottom","intersectRect","rectangle","containsRect","getCenterWidth","getCenterHeight","clone","equals","rect","toString","Vector2","subtract","vector2","distance","Math","sqrt","magnitude","normalize","normalX","normalY","isNaN","enemyImage","wayPointReachedThreshold","moveSpeed","hp","maxHp","topPadding","hpRemainingBarColor","hpFullBarColor","alive","originalWayPoints","window","tileMap","wayPoints","reset","active","movementWayPoints","slice","movements","up","down","position","size","center","velocity","bounds","nextMovePoint","hpBounds","liveBounds","enemyName","random","onLastWaypoint","firstWayPoint","shift","waypointBounds","tileMatrix","updateBounds","updateHpBounds","direction","distanceFromNextWaypoint","nextWaypointReached","dispatchEvent","CustomEvent","nextWayPoint","normalizedDirection","Number","setMoveDirection","applyVelocity","updateLifeBounds","percentageDiff","percentageLive","draw","renderEngine","renderImageSource","drawRemainingHPBar","drawFullHPBar","renderRect","hit","enemies","enemySpawnCount","enemySpawnElapsed","enemiesKilled","enemiesEscaped","assetManager","setCurrentLevel","addEventListener","enemy","updateSpawner","updateRoundCheck","enemySpawnCountMax","enemySpawnRate","createEnemy","levelManager","currentLevel","nextLevel","Enemy","enemyMoveSpeed","enemyMaxHp","loadLevel","index","levelIndex","l","stagedTowerImageWidth","stagedTowerImageHeight","towerClicked","menuHeight","document","getElementById","clientHeight","imageDictionary","clearStagedTower","stagedTower","type","mouseInfo","tX","tY","find","renderImage","projectileImage","ttl","ttlMax","worldBounds","projectileColor","imageSourceRect","updateTTL","updateVelocity","startPosition","projectiles","projectile","activateProjectile","poolSufficient","i","expandProjectilePool","Projectile","GameScene","collisionCheckElapsed","backgroundImage","tileImage","LevelManager","menu","Menu","TileMap","enemySpawner","EnemySpawner","towerManager","TowerManager","projectileEngine","ProjectileEngine","createTower","e","mouseMove","mouseDown","mouseUp","gameTime","checkProjectileEnemyCollision","render","clearRect","renderText","levelName","static","getElementBounds","elementId","element","clientLeft","clientTop","clientWidth","isOverMouseMenu","isOverGameBounds","floor","tileWidth","tileHeight","destinationTile","log","resize","loadScreenRect","loadingText","sceneManager","toggleActiveScene","Scenes","game","loadScene","LoadScene","gameScene","newScene","loading","currentScene","imageObject","fontSize","col","row","rows","gameConfig","tileMapRows","cols","tileMapCols","tileMapTileWidth","tileMapTileHeight","initTileMatrix","matrix","matrixValue","tileImageObject","getTileImageObject","tileBounds","Tile","destinationX","destinationY","ImageObject","towerImage","shootRange","updateTarget","updateTargetInRange","updateRotation","drawRange","renderRotatedImageSource","rotation","drawSelection","setSelection","selected","renderEllipse","target","targetDirection","targetInRange","xDistance","yDistance","atan2","PI","closestEnemy","closestDistance","PlainTower","BaseTower","super","plainTowerShootSpeed","plainTowerShootRate","shootElapsed","updateShoot","towers","tower","canvasWidth","canvasHeight","backgroundBounds","gameCanvas","context","getContext","color","fill","originalFillStyle","fillStyle","originalStrokeStyle","strokeStyle","fillRect","beginPath","strokeRect","text","fontFamily","font","fillText","renderImageRect","w","h","drawImage","destRect","save","translate","rotate","rotatedDestRect","restore","centerX","centerY","opacity","radius","globalAlpha","ellipse","stroke","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","Game","GameConfig","RenderEngine","AssetManager","SceneManager","GameTime","start","running","loop","requestAnimationFrame","event"],"sourceRoot":""}